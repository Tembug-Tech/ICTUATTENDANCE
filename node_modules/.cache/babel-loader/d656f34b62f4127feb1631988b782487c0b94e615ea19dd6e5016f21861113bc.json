{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { SESSION_STATUS, calculateSessionStatus, getStudentSessionsByStatus, getDelegateSessionsByStatus, markAttendanceWithStatus, processSessionClosure, getTimeRemaining } from '../utils/sessionLifecycle';\n\n/**\r\n * Custom hook for managing session lifecycle with real-time updates\r\n * Automatically updates session statuses based on time\r\n * \r\n * @param {string} userId - User's ID\r\n * @param {string} role - User's role ('student' or 'delegate')\r\n * @param {number} refreshInterval - Interval in ms for checking status updates (default: 10000)\r\n */\nexport const useSessionLifecycle = (userId, role, refreshInterval = 10000) => {\n  _s();\n  const [sessions, setSessions] = useState({\n    scheduled: [],\n    open: [],\n    closed: []\n  });\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastUpdate, setLastUpdate] = useState(null);\n\n  // Track sessions that have transitioned to closed for processing\n  const processedClosures = useRef(new Set());\n\n  // Fetch sessions based on role\n  const fetchSessions = useCallback(async () => {\n    if (!userId) return;\n    try {\n      setLoading(true);\n      setError(null);\n      let result;\n      if (role === 'student') {\n        result = await getStudentSessionsByStatus(userId);\n      } else if (role === 'delegate') {\n        result = await getDelegateSessionsByStatus(userId);\n      } else {\n        throw new Error('Invalid role');\n      }\n      if (result.error) {\n        throw new Error(result.error);\n      }\n      setSessions({\n        scheduled: result.scheduled || [],\n        open: result.open || [],\n        closed: result.closed || []\n      });\n      setLastUpdate(new Date());\n    } catch (err) {\n      console.error('Error fetching sessions:', err);\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [userId, role]);\n\n  // Check for status transitions and update accordingly\n  const checkStatusTransitions = useCallback(() => {\n    const now = new Date();\n    let hasChanges = false;\n\n    // Check scheduled sessions that should now be open\n    const newScheduled = [];\n    const newOpen = [...sessions.open];\n    for (const session of sessions.scheduled) {\n      const currentStatus = calculateSessionStatus({\n        session_date: session.date,\n        start_time: session.startTime,\n        end_time: session.endTime\n      });\n      if (currentStatus === SESSION_STATUS.OPEN) {\n        newOpen.push({\n          ...session,\n          status: SESSION_STATUS.OPEN\n        });\n        hasChanges = true;\n      } else {\n        newScheduled.push(session);\n      }\n    }\n\n    // Check open sessions that should now be closed\n    const newClosed = [...sessions.closed];\n    const stillOpen = [];\n    for (const session of newOpen) {\n      const currentStatus = calculateSessionStatus({\n        session_date: session.date,\n        start_time: session.startTime,\n        end_time: session.endTime\n      });\n      if (currentStatus === SESSION_STATUS.CLOSED) {\n        newClosed.push({\n          ...session,\n          status: SESSION_STATUS.CLOSED\n        });\n        hasChanges = true;\n\n        // Process session closure (auto-mark absent) if not already processed\n        if (!processedClosures.current.has(session.id)) {\n          processedClosures.current.add(session.id);\n          processSessionClosure(session.id).catch(console.error);\n        }\n      } else {\n        stillOpen.push(session);\n      }\n    }\n    if (hasChanges) {\n      setSessions({\n        scheduled: newScheduled,\n        open: stillOpen,\n        closed: newClosed\n      });\n      setLastUpdate(new Date());\n    }\n  }, [sessions]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchSessions();\n  }, [fetchSessions]);\n\n  // Set up interval for checking status transitions\n  useEffect(() => {\n    const interval = setInterval(() => {\n      checkStatusTransitions();\n    }, refreshInterval);\n    return () => clearInterval(interval);\n  }, [checkStatusTransitions, refreshInterval]);\n\n  // Refresh data periodically (every 30 seconds)\n  useEffect(() => {\n    const interval = setInterval(() => {\n      fetchSessions();\n    }, 30000);\n    return () => clearInterval(interval);\n  }, [fetchSessions]);\n\n  // Mark attendance function\n  const markAttendance = useCallback(async sessionId => {\n    if (!userId) {\n      return {\n        success: false,\n        error: 'User not authenticated'\n      };\n    }\n    const result = await markAttendanceWithStatus(userId, sessionId);\n    if (result.success) {\n      // Update local state to reflect the change\n      setSessions(prev => ({\n        ...prev,\n        open: prev.open.map(s => s.id === sessionId ? {\n          ...s,\n          isMarked: true,\n          attendanceStatus: result.status\n        } : s)\n      }));\n    }\n    return result;\n  }, [userId]);\n\n  // Get time remaining for a session\n  const getSessionTimeRemaining = useCallback(session => {\n    return getTimeRemaining({\n      session_date: session.date,\n      start_time: session.startTime,\n      end_time: session.endTime\n    });\n  }, []);\n\n  // Get all active sessions (open sessions)\n  const activeSessions = sessions.open;\n\n  // Get upcoming sessions (scheduled)\n  const upcomingSessions = sessions.scheduled;\n\n  // Get past sessions (closed)\n  const pastSessions = sessions.closed;\n\n  // Get sessions that need attention (open but not marked for students)\n  const sessionsNeedingAttention = role === 'student' ? sessions.open.filter(s => !s.isMarked) : sessions.open;\n  return {\n    sessions,\n    activeSessions,\n    upcomingSessions,\n    pastSessions,\n    sessionsNeedingAttention,\n    loading,\n    error,\n    lastUpdate,\n    refresh: fetchSessions,\n    markAttendance,\n    getSessionTimeRemaining\n  };\n};\n\n/**\r\n * Custom hook for countdown timer\r\n * @param {Object} session - Session object\r\n * @param {number} updateInterval - Update interval in ms (default: 1000)\r\n */\n_s(useSessionLifecycle, \"FQadmKjmQmrnVm0KfF/MW7SKRCc=\");\nexport const useSessionCountdown = (session, updateInterval = 1000) => {\n  _s2();\n  const [timeRemaining, setTimeRemaining] = useState(null);\n  useEffect(() => {\n    if (!session) return;\n    const updateTime = () => {\n      const remaining = getTimeRemaining({\n        session_date: session.date || session.session_date,\n        start_time: session.startTime || session.start_time,\n        end_time: session.endTime || session.end_time\n      });\n      setTimeRemaining(remaining);\n    };\n    updateTime();\n    const interval = setInterval(updateTime, updateInterval);\n    return () => clearInterval(interval);\n  }, [session, updateInterval]);\n  return timeRemaining;\n};\n\n/**\r\n * Custom hook for real-time session status\r\n * @param {Object} session - Session object\r\n */\n_s2(useSessionCountdown, \"JhnAQ7JP3vprPrD01Jxl+Bn4zHQ=\");\nexport const useSessionStatus = session => {\n  _s3();\n  const [status, setStatus] = useState(null);\n  useEffect(() => {\n    if (!session) return;\n    const updateStatus = () => {\n      const currentStatus = calculateSessionStatus({\n        session_date: session.date || session.session_date,\n        start_time: session.startTime || session.start_time,\n        end_time: session.endTime || session.end_time\n      });\n      setStatus(currentStatus);\n    };\n    updateStatus();\n    const interval = setInterval(updateStatus, 5000);\n    return () => clearInterval(interval);\n  }, [session]);\n  return status;\n};\n_s3(useSessionStatus, \"BS896UqrqyybjEKvhypabDkHm2E=\");\nexport default useSessionLifecycle;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","SESSION_STATUS","calculateSessionStatus","getStudentSessionsByStatus","getDelegateSessionsByStatus","markAttendanceWithStatus","processSessionClosure","getTimeRemaining","useSessionLifecycle","userId","role","refreshInterval","_s","sessions","setSessions","scheduled","open","closed","loading","setLoading","error","setError","lastUpdate","setLastUpdate","processedClosures","Set","fetchSessions","result","Error","Date","err","console","message","checkStatusTransitions","now","hasChanges","newScheduled","newOpen","session","currentStatus","session_date","date","start_time","startTime","end_time","endTime","OPEN","push","status","newClosed","stillOpen","CLOSED","current","has","id","add","catch","interval","setInterval","clearInterval","markAttendance","sessionId","success","prev","map","s","isMarked","attendanceStatus","getSessionTimeRemaining","activeSessions","upcomingSessions","pastSessions","sessionsNeedingAttention","filter","refresh","useSessionCountdown","updateInterval","_s2","timeRemaining","setTimeRemaining","updateTime","remaining","useSessionStatus","_s3","setStatus","updateStatus"],"sources":["C:/Users/PFI/Desktop/ictuattennce_portal/ATTENDANCE/src/hooks/useSessionLifecycle.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n    SESSION_STATUS,\r\n    calculateSessionStatus,\r\n    getStudentSessionsByStatus,\r\n    getDelegateSessionsByStatus,\r\n    markAttendanceWithStatus,\r\n    processSessionClosure,\r\n    getTimeRemaining\r\n} from '../utils/sessionLifecycle';\r\n\r\n/**\r\n * Custom hook for managing session lifecycle with real-time updates\r\n * Automatically updates session statuses based on time\r\n * \r\n * @param {string} userId - User's ID\r\n * @param {string} role - User's role ('student' or 'delegate')\r\n * @param {number} refreshInterval - Interval in ms for checking status updates (default: 10000)\r\n */\r\nexport const useSessionLifecycle = (userId, role, refreshInterval = 10000) => {\r\n    const [sessions, setSessions] = useState({\r\n        scheduled: [],\r\n        open: [],\r\n        closed: []\r\n    });\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState(null);\r\n    const [lastUpdate, setLastUpdate] = useState(null);\r\n\r\n    // Track sessions that have transitioned to closed for processing\r\n    const processedClosures = useRef(new Set());\r\n\r\n    // Fetch sessions based on role\r\n    const fetchSessions = useCallback(async () => {\r\n        if (!userId) return;\r\n\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n\r\n            let result;\r\n            if (role === 'student') {\r\n                result = await getStudentSessionsByStatus(userId);\r\n            } else if (role === 'delegate') {\r\n                result = await getDelegateSessionsByStatus(userId);\r\n            } else {\r\n                throw new Error('Invalid role');\r\n            }\r\n\r\n            if (result.error) {\r\n                throw new Error(result.error);\r\n            }\r\n\r\n            setSessions({\r\n                scheduled: result.scheduled || [],\r\n                open: result.open || [],\r\n                closed: result.closed || []\r\n            });\r\n            setLastUpdate(new Date());\r\n        } catch (err) {\r\n            console.error('Error fetching sessions:', err);\r\n            setError(err.message);\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [userId, role]);\r\n\r\n    // Check for status transitions and update accordingly\r\n    const checkStatusTransitions = useCallback(() => {\r\n        const now = new Date();\r\n        let hasChanges = false;\r\n\r\n        // Check scheduled sessions that should now be open\r\n        const newScheduled = [];\r\n        const newOpen = [...sessions.open];\r\n\r\n        for (const session of sessions.scheduled) {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date,\r\n                start_time: session.startTime,\r\n                end_time: session.endTime\r\n            });\r\n\r\n            if (currentStatus === SESSION_STATUS.OPEN) {\r\n                newOpen.push({ ...session, status: SESSION_STATUS.OPEN });\r\n                hasChanges = true;\r\n            } else {\r\n                newScheduled.push(session);\r\n            }\r\n        }\r\n\r\n        // Check open sessions that should now be closed\r\n        const newClosed = [...sessions.closed];\r\n        const stillOpen = [];\r\n\r\n        for (const session of newOpen) {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date,\r\n                start_time: session.startTime,\r\n                end_time: session.endTime\r\n            });\r\n\r\n            if (currentStatus === SESSION_STATUS.CLOSED) {\r\n                newClosed.push({ ...session, status: SESSION_STATUS.CLOSED });\r\n                hasChanges = true;\r\n\r\n                // Process session closure (auto-mark absent) if not already processed\r\n                if (!processedClosures.current.has(session.id)) {\r\n                    processedClosures.current.add(session.id);\r\n                    processSessionClosure(session.id).catch(console.error);\r\n                }\r\n            } else {\r\n                stillOpen.push(session);\r\n            }\r\n        }\r\n\r\n        if (hasChanges) {\r\n            setSessions({\r\n                scheduled: newScheduled,\r\n                open: stillOpen,\r\n                closed: newClosed\r\n            });\r\n            setLastUpdate(new Date());\r\n        }\r\n    }, [sessions]);\r\n\r\n    // Initial fetch\r\n    useEffect(() => {\r\n        fetchSessions();\r\n    }, [fetchSessions]);\r\n\r\n    // Set up interval for checking status transitions\r\n    useEffect(() => {\r\n        const interval = setInterval(() => {\r\n            checkStatusTransitions();\r\n        }, refreshInterval);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [checkStatusTransitions, refreshInterval]);\r\n\r\n    // Refresh data periodically (every 30 seconds)\r\n    useEffect(() => {\r\n        const interval = setInterval(() => {\r\n            fetchSessions();\r\n        }, 30000);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [fetchSessions]);\r\n\r\n    // Mark attendance function\r\n    const markAttendance = useCallback(async (sessionId) => {\r\n        if (!userId) {\r\n            return { success: false, error: 'User not authenticated' };\r\n        }\r\n\r\n        const result = await markAttendanceWithStatus(userId, sessionId);\r\n\r\n        if (result.success) {\r\n            // Update local state to reflect the change\r\n            setSessions(prev => ({\r\n                ...prev,\r\n                open: prev.open.map(s =>\r\n                    s.id === sessionId\r\n                        ? { ...s, isMarked: true, attendanceStatus: result.status }\r\n                        : s\r\n                )\r\n            }));\r\n        }\r\n\r\n        return result;\r\n    }, [userId]);\r\n\r\n    // Get time remaining for a session\r\n    const getSessionTimeRemaining = useCallback((session) => {\r\n        return getTimeRemaining({\r\n            session_date: session.date,\r\n            start_time: session.startTime,\r\n            end_time: session.endTime\r\n        });\r\n    }, []);\r\n\r\n    // Get all active sessions (open sessions)\r\n    const activeSessions = sessions.open;\r\n\r\n    // Get upcoming sessions (scheduled)\r\n    const upcomingSessions = sessions.scheduled;\r\n\r\n    // Get past sessions (closed)\r\n    const pastSessions = sessions.closed;\r\n\r\n    // Get sessions that need attention (open but not marked for students)\r\n    const sessionsNeedingAttention = role === 'student'\r\n        ? sessions.open.filter(s => !s.isMarked)\r\n        : sessions.open;\r\n\r\n    return {\r\n        sessions,\r\n        activeSessions,\r\n        upcomingSessions,\r\n        pastSessions,\r\n        sessionsNeedingAttention,\r\n        loading,\r\n        error,\r\n        lastUpdate,\r\n        refresh: fetchSessions,\r\n        markAttendance,\r\n        getSessionTimeRemaining\r\n    };\r\n};\r\n\r\n/**\r\n * Custom hook for countdown timer\r\n * @param {Object} session - Session object\r\n * @param {number} updateInterval - Update interval in ms (default: 1000)\r\n */\r\nexport const useSessionCountdown = (session, updateInterval = 1000) => {\r\n    const [timeRemaining, setTimeRemaining] = useState(null);\r\n\r\n    useEffect(() => {\r\n        if (!session) return;\r\n\r\n        const updateTime = () => {\r\n            const remaining = getTimeRemaining({\r\n                session_date: session.date || session.session_date,\r\n                start_time: session.startTime || session.start_time,\r\n                end_time: session.endTime || session.end_time\r\n            });\r\n            setTimeRemaining(remaining);\r\n        };\r\n\r\n        updateTime();\r\n        const interval = setInterval(updateTime, updateInterval);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [session, updateInterval]);\r\n\r\n    return timeRemaining;\r\n};\r\n\r\n/**\r\n * Custom hook for real-time session status\r\n * @param {Object} session - Session object\r\n */\r\nexport const useSessionStatus = (session) => {\r\n    const [status, setStatus] = useState(null);\r\n\r\n    useEffect(() => {\r\n        if (!session) return;\r\n\r\n        const updateStatus = () => {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date || session.session_date,\r\n                start_time: session.startTime || session.start_time,\r\n                end_time: session.endTime || session.end_time\r\n            });\r\n            setStatus(currentStatus);\r\n        };\r\n\r\n        updateStatus();\r\n        const interval = setInterval(updateStatus, 5000);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [session]);\r\n\r\n    return status;\r\n};\r\n\r\nexport default useSessionLifecycle;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}