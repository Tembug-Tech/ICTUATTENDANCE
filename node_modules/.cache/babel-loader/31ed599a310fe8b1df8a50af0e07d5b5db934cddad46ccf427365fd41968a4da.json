{"ast":null,"code":"import { supabase } from '../supabase/supabase';\n\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\n\n// Session status constants\nexport const SESSION_STATUS = {\n  SCHEDULED: 'scheduled',\n  OPEN: 'open',\n  CLOSED: 'closed'\n};\n\n// Attendance status constants\nexport const ATTENDANCE_STATUS = {\n  PRESENT: 'present',\n  LATE: 'late',\n  ABSENT: 'absent'\n};\n\n// Late window in minutes (first 10 minutes after session start)\nexport const LATE_WINDOW_MINUTES = 10;\n\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\n// Helper function to convert Cameroon time to UTC\nconst cameroonToUTC = (date, hour, min) => {\n  const cameroonTime = new Date(date);\n  cameroonTime.setHours(hour, min, 0, 0);\n  // Cameroon is UTC+1, so subtract 1 hour to get UTC\n  return new Date(cameroonTime.getTime() - 1 * 60 * 60 * 1000);\n};\n\n// Helper function to convert UTC to Cameroon time\nconst utcToCameroon = utcDate => {\n  // Add 1 hour to UTC to get Cameroon time\n  return new Date(utcDate.getTime() + 1 * 60 * 60 * 1000);\n};\nexport const calculateSessionStatus = session => {\n  const now = new Date();\n\n  // Handle different property names (database vs transformed)\n  const sessionDate = session.session_date || session.date;\n  const startTime = session.start_time || session.startTime;\n  const endTime = session.end_time || session.endTime;\n\n  // Parse start and end times as Cameroon time, then convert to UTC for comparison\n  const [startHour, startMin] = startTime.split(':').map(Number);\n  const [endHour, endMin] = endTime.split(':').map(Number);\n  const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\n  const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\n\n  // Convert current time to UTC for comparison\n  const nowUTC = new Date(now.getTime() - now.getTimezoneOffset() * 60 * 1000);\n\n  // Determine status\n  if (nowUTC < startDateTimeUTC) {\n    return SESSION_STATUS.SCHEDULED;\n  } else if (nowUTC >= startDateTimeUTC && nowUTC <= endDateTimeUTC) {\n    return SESSION_STATUS.OPEN;\n  } else {\n    return SESSION_STATUS.CLOSED;\n  }\n};\n\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\nexport const canMarkAttendance = async (session, studentId) => {\n  const status = calculateSessionStatus(session);\n\n  // Check if session is open\n  if (status === SESSION_STATUS.SCHEDULED) {\n    return {\n      canMark: false,\n      reason: 'Session has not started yet',\n      status\n    };\n  }\n  if (status === SESSION_STATUS.CLOSED) {\n    return {\n      canMark: false,\n      reason: 'Session has ended. Attendance is locked.',\n      status\n    };\n  }\n\n  // Check if student is enrolled in the course\n  const {\n    data: classData,\n    error: classError\n  } = await supabase.from('classes').select('course_id').eq('id', session.class_id).single();\n  if (classError || !classData) {\n    return {\n      canMark: false,\n      reason: 'Unable to verify enrollment',\n      status\n    };\n  }\n  const {\n    data: enrollment,\n    error: enrollError\n  } = await supabase.from('enrollments').select('id').eq('student_id', studentId).eq('course_id', classData.course_id).single();\n  if (enrollError || !enrollment) {\n    return {\n      canMark: false,\n      reason: 'You are not enrolled in this course',\n      status\n    };\n  }\n\n  // Check if student has already marked attendance\n  const {\n    data: existingAttendance,\n    error: attendanceError\n  } = await supabase.from('attendance').select('id').eq('session_id', session.id).eq('student_id', studentId).single();\n  if (existingAttendance) {\n    return {\n      canMark: false,\n      reason: 'You have already marked attendance for this session',\n      status\n    };\n  }\n  return {\n    canMark: true,\n    reason: 'Ready to mark attendance',\n    status\n  };\n};\n\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\nexport const isLateAttendance = session => {\n  const now = new Date();\n  const sessionDate = session.session_date;\n  const [startHour, startMin] = session.start_time.split(':').map(Number);\n  const startDateTime = new Date(sessionDate);\n  startDateTime.setHours(startHour, startMin, 0, 0);\n  const lateThreshold = new Date(startDateTime);\n  lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\n  return now > lateThreshold;\n};\n\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\n  try {\n    // First get the session details\n    const {\n      data: session,\n      error: sessionError\n    } = await supabase.from('sessions').select('*').eq('id', sessionId).single();\n    if (sessionError || !session) {\n      return {\n        success: false,\n        attendance: null,\n        error: 'Session not found'\n      };\n    }\n\n    // Check if student can mark attendance\n    const {\n      canMark,\n      reason,\n      status\n    } = await canMarkAttendance(session, studentId);\n    if (!canMark) {\n      return {\n        success: false,\n        attendance: null,\n        error: reason\n      };\n    }\n\n    // Determine attendance status (present or late)\n    const attendanceStatus = isLateAttendance(session) ? ATTENDANCE_STATUS.LATE : ATTENDANCE_STATUS.PRESENT;\n\n    // Insert attendance record\n    const {\n      data,\n      error\n    } = await supabase.from('attendance').insert({\n      student_id: studentId,\n      session_id: sessionId,\n      status: attendanceStatus,\n      marked_at: new Date().toISOString()\n    }).select();\n    if (error) {\n      // Check for duplicate entry\n      if (error.code === '23505') {\n        return {\n          success: false,\n          attendance: null,\n          error: 'Attendance already marked'\n        };\n      }\n      throw error;\n    }\n    return {\n      success: true,\n      attendance: data === null || data === void 0 ? void 0 : data[0],\n      error: null,\n      status: attendanceStatus,\n      message: attendanceStatus === ATTENDANCE_STATUS.LATE ? 'Attendance marked as LATE' : 'Attendance marked successfully!'\n    };\n  } catch (error) {\n    console.error('Error marking attendance:', error);\n    return {\n      success: false,\n      attendance: null,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\nexport const autoMarkAbsentStudents = async sessionId => {\n  try {\n    // Get session details\n    const {\n      data: session,\n      error: sessionError\n    } = await supabase.from('sessions').select('*, classes!inner(course_id)').eq('id', sessionId).single();\n    if (sessionError || !session) {\n      return {\n        success: false,\n        absentCount: 0,\n        error: 'Session not found'\n      };\n    }\n\n    // Check if session is closed\n    const status = calculateSessionStatus(session);\n    if (status !== SESSION_STATUS.CLOSED) {\n      return {\n        success: false,\n        absentCount: 0,\n        error: 'Session is not closed yet'\n      };\n    }\n\n    // Get all enrolled students for this course\n    const {\n      data: enrollments,\n      error: enrollError\n    } = await supabase.from('enrollments').select('student_id').eq('course_id', session.classes.course_id);\n    if (enrollError) {\n      throw enrollError;\n    }\n\n    // Get students who already marked attendance\n    const {\n      data: presentStudents,\n      error: presentError\n    } = await supabase.from('attendance').select('student_id').eq('session_id', sessionId);\n    if (presentError) {\n      throw presentError;\n    }\n    const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\n\n    // Find students who didn't mark attendance\n    const absentStudents = (enrollments || []).filter(e => !presentStudentIds.has(e.student_id)).map(e => ({\n      student_id: e.student_id,\n      session_id: sessionId,\n      status: ATTENDANCE_STATUS.ABSENT,\n      marked_at: new Date().toISOString()\n    }));\n    if (absentStudents.length === 0) {\n      return {\n        success: true,\n        absentCount: 0,\n        error: null\n      };\n    }\n\n    // Insert absent records\n    const {\n      error: insertError\n    } = await supabase.from('attendance').insert(absentStudents);\n    if (insertError) {\n      throw insertError;\n    }\n    return {\n      success: true,\n      absentCount: absentStudents.length,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error auto-marking absent students:', error);\n    return {\n      success: false,\n      absentCount: 0,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\n  try {\n    let query = supabase.from('sessions').select('id, start_time, end_time').eq('class_id', classId).eq('session_date', date);\n    if (excludeSessionId) {\n      query = query.neq('id', excludeSessionId);\n    }\n    const {\n      data: sessions,\n      error\n    } = await query;\n    if (error) {\n      throw error;\n    }\n\n    // Check for time overlaps\n    const overlapping = (sessions || []).filter(session => {\n      const existingStart = session.start_time;\n      const existingEnd = session.end_time;\n\n      // Check if times overlap\n      return startTime < existingEnd && endTime > existingStart;\n    });\n    return {\n      hasOverlap: overlapping.length > 0,\n      overlappingSessions: overlapping\n    };\n  } catch (error) {\n    console.error('Error checking overlapping sessions:', error);\n    return {\n      hasOverlap: false,\n      overlappingSessions: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\n  try {\n    // Check for overlapping sessions\n    const {\n      hasOverlap,\n      overlappingSessions\n    } = await checkOverlappingSessions(classId, sessionDate, startTime, endTime);\n    if (hasOverlap) {\n      return {\n        session: null,\n        error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\n      };\n    }\n\n    // Generate a unique token\n    const token = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n\n    // Calculate expires_at (same as end time for automatic closure) in UTC\n    const [endHour, endMin] = endTime.split(':');\n    const expiresAt = cameroonToUTC(sessionDate, parseInt(endHour), parseInt(endMin));\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').insert({\n      class_id: classId,\n      session_date: sessionDate,\n      start_time: startTime,\n      end_time: endTime,\n      token,\n      expires_at: expiresAt.toISOString()\n    }).select();\n    if (error) throw error;\n    return {\n      session: data === null || data === void 0 ? void 0 : data[0],\n      error: null\n    };\n  } catch (error) {\n    console.error('Error creating session:', error);\n    return {\n      session: null,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\nexport const getStudentSessionsByStatus = async studentId => {\n  try {\n    // Get student's enrolled courses\n    const {\n      data: enrollments,\n      error: enrollError\n    } = await supabase.from('enrollments').select('course_id').eq('student_id', studentId);\n    if (enrollError) throw enrollError;\n    const courseIds = (enrollments || []).map(e => e.course_id);\n\n    // Get classes for these courses\n    const {\n      data: classes,\n      error: classError\n    } = await supabase.from('classes').select('id').in('course_id', courseIds);\n    if (classError) throw classError;\n    const classIds = (classes || []).map(c => c.id);\n\n    // Get all sessions for these classes\n    const {\n      data: sessions,\n      error: sessionError\n    } = await supabase.from('sessions').select(`\n        id,\n        session_date,\n        start_time,\n        end_time,\n        token,\n        expires_at,\n        classes!inner (\n          id,\n          class_name,\n          courses!inner (course_code, course_title)\n        )\n      `).in('class_id', classIds).order('session_date', {\n      ascending: false\n    });\n    if (sessionError) throw sessionError;\n\n    // Get student's attendance records\n    const {\n      data: attendance,\n      error: attendanceError\n    } = await supabase.from('attendance').select('session_id, status').eq('student_id', studentId);\n    if (attendanceError) throw attendanceError;\n    const attendanceMap = new Map((attendance || []).map(a => [a.session_id, a.status]));\n\n    // Categorize sessions by status\n    const scheduled = [];\n    const open = [];\n    const closed = [];\n    for (const session of sessions || []) {\n      var _session$classes, _session$classes$cour, _session$classes2, _session$classes2$cou, _session$classes3;\n      const status = calculateSessionStatus(session);\n      const isMarked = attendanceMap.has(session.id);\n      const attendanceStatus = attendanceMap.get(session.id);\n      const enrichedSession = {\n        id: session.id,\n        courseCode: (_session$classes = session.classes) === null || _session$classes === void 0 ? void 0 : (_session$classes$cour = _session$classes.courses) === null || _session$classes$cour === void 0 ? void 0 : _session$classes$cour.course_code,\n        courseTitle: (_session$classes2 = session.classes) === null || _session$classes2 === void 0 ? void 0 : (_session$classes2$cou = _session$classes2.courses) === null || _session$classes2$cou === void 0 ? void 0 : _session$classes2$cou.course_title,\n        className: (_session$classes3 = session.classes) === null || _session$classes3 === void 0 ? void 0 : _session$classes3.class_name,\n        date: new Date(session.session_date).toLocaleDateString(),\n        startTime: session.start_time,\n        endTime: session.end_time,\n        status,\n        isMarked,\n        attendanceStatus,\n        token: session.token\n      };\n      switch (status) {\n        case SESSION_STATUS.SCHEDULED:\n          scheduled.push(enrichedSession);\n          break;\n        case SESSION_STATUS.OPEN:\n          open.push(enrichedSession);\n          break;\n        case SESSION_STATUS.CLOSED:\n          closed.push(enrichedSession);\n          break;\n      }\n    }\n    return {\n      scheduled,\n      open,\n      closed,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching student sessions:', error);\n    return {\n      scheduled: [],\n      open: [],\n      closed: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\nexport const getDelegateSessionsByStatus = async delegateId => {\n  try {\n    // Get delegate's classes\n    const {\n      data: classes,\n      error: classError\n    } = await supabase.from('classes').select('id').eq('delegate_id', delegateId);\n    if (classError) throw classError;\n    const classIds = (classes || []).map(c => c.id);\n\n    // Get all sessions for these classes\n    const {\n      data: sessions,\n      error: sessionError\n    } = await supabase.from('sessions').select(`\n        id,\n        session_date,\n        start_time,\n        end_time,\n        token,\n        expires_at,\n        classes!inner (\n          id,\n          class_name,\n          courses!inner (course_code, course_title)\n        )\n      `).in('class_id', classIds).order('session_date', {\n      ascending: false\n    });\n    if (sessionError) throw sessionError;\n\n    // Get attendance counts for each session\n    const sessionIds = (sessions || []).map(s => s.id);\n    const {\n      data: attendanceCounts,\n      error: countError\n    } = await supabase.from('attendance').select('session_id').in('session_id', sessionIds);\n\n    // Count attendance per session\n    const countMap = new Map();\n    (attendanceCounts || []).forEach(a => {\n      countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\n    });\n\n    // Categorize sessions by status\n    const scheduled = [];\n    const open = [];\n    const closed = [];\n    for (const session of sessions || []) {\n      var _session$classes4, _session$classes4$cou, _session$classes5, _session$classes5$cou, _session$classes6;\n      const status = calculateSessionStatus(session);\n      const enrichedSession = {\n        id: session.id,\n        courseCode: (_session$classes4 = session.classes) === null || _session$classes4 === void 0 ? void 0 : (_session$classes4$cou = _session$classes4.courses) === null || _session$classes4$cou === void 0 ? void 0 : _session$classes4$cou.course_code,\n        courseTitle: (_session$classes5 = session.classes) === null || _session$classes5 === void 0 ? void 0 : (_session$classes5$cou = _session$classes5.courses) === null || _session$classes5$cou === void 0 ? void 0 : _session$classes5$cou.course_title,\n        className: (_session$classes6 = session.classes) === null || _session$classes6 === void 0 ? void 0 : _session$classes6.class_name,\n        date: new Date(session.session_date).toLocaleDateString(),\n        startTime: session.start_time,\n        endTime: session.end_time,\n        status,\n        attendanceCount: countMap.get(session.id) || 0,\n        token: session.token\n      };\n      switch (status) {\n        case SESSION_STATUS.SCHEDULED:\n          scheduled.push(enrichedSession);\n          break;\n        case SESSION_STATUS.OPEN:\n          open.push(enrichedSession);\n          break;\n        case SESSION_STATUS.CLOSED:\n          closed.push(enrichedSession);\n          break;\n      }\n    }\n    return {\n      scheduled,\n      open,\n      closed,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching delegate sessions:', error);\n    return {\n      scheduled: [],\n      open: [],\n      closed: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\nexport const processSessionClosure = async sessionId => {\n  try {\n    // Auto-mark absent students\n    const result = await autoMarkAbsentStudents(sessionId);\n    if (!result.success) {\n      console.error('Failed to auto-mark absent students:', result.error);\n    } else {\n      console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\n    }\n    return result;\n  } catch (error) {\n    console.error('Error processing session closure:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\nexport const getTimeRemaining = session => {\n  const now = new Date();\n\n  // Handle different property names\n  const sessionDate = session.session_date || session.date;\n  const startTime = session.start_time || session.startTime;\n  const endTime = session.end_time || session.endTime;\n  const [startHour, startMin] = startTime.split(':').map(Number);\n  const [endHour, endMin] = endTime.split(':').map(Number);\n  const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\n  const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\n  const nowUTC = new Date(now.getTime() - now.getTimezoneOffset() * 60 * 1000);\n  if (nowUTC < startDateTimeUTC) {\n    const diffMs = startDateTimeUTC - nowUTC;\n    const minutes = Math.floor(diffMs / 60000);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return {\n      type: 'start',\n      minutes,\n      formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\n    };\n  } else if (nowUTC < endDateTimeUTC) {\n    const diffMs = endDateTimeUTC - nowUTC;\n    const minutes = Math.floor(diffMs / 60000);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return {\n      type: 'end',\n      minutes,\n      formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\n    };\n  }\n  return {\n    type: 'ended',\n    minutes: 0,\n    formatted: 'Session ended'\n  };\n};","map":{"version":3,"names":["supabase","SESSION_STATUS","SCHEDULED","OPEN","CLOSED","ATTENDANCE_STATUS","PRESENT","LATE","ABSENT","LATE_WINDOW_MINUTES","cameroonToUTC","date","hour","min","cameroonTime","Date","setHours","getTime","utcToCameroon","utcDate","calculateSessionStatus","session","now","sessionDate","session_date","startTime","start_time","endTime","end_time","startHour","startMin","split","map","Number","endHour","endMin","startDateTimeUTC","endDateTimeUTC","nowUTC","getTimezoneOffset","canMarkAttendance","studentId","status","canMark","reason","data","classData","error","classError","from","select","eq","class_id","single","enrollment","enrollError","course_id","existingAttendance","attendanceError","id","isLateAttendance","startDateTime","lateThreshold","setMinutes","getMinutes","markAttendanceWithStatus","sessionId","sessionError","success","attendance","attendanceStatus","insert","student_id","session_id","marked_at","toISOString","code","message","console","autoMarkAbsentStudents","absentCount","enrollments","classes","presentStudents","presentError","presentStudentIds","Set","a","absentStudents","filter","e","has","length","insertError","checkOverlappingSessions","classId","excludeSessionId","query","neq","sessions","overlapping","existingStart","existingEnd","hasOverlap","overlappingSessions","createSessionWithValidation","delegateId","s","join","token","Math","random","toString","substring","expiresAt","parseInt","expires_at","getStudentSessionsByStatus","courseIds","in","classIds","c","order","ascending","attendanceMap","Map","scheduled","open","closed","_session$classes","_session$classes$cour","_session$classes2","_session$classes2$cou","_session$classes3","isMarked","get","enrichedSession","courseCode","courses","course_code","courseTitle","course_title","className","class_name","toLocaleDateString","push","getDelegateSessionsByStatus","sessionIds","attendanceCounts","countError","countMap","forEach","set","_session$classes4","_session$classes4$cou","_session$classes5","_session$classes5$cou","_session$classes6","attendanceCount","processSessionClosure","result","log","getTimeRemaining","diffMs","minutes","floor","hours","mins","type","formatted"],"sources":["C:/Users/PFI/Desktop/ictuattennce_portal/ATTENDANCE/src/utils/sessionLifecycle.js"],"sourcesContent":["import { supabase } from '../supabase/supabase';\r\n\r\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\r\n\r\n// Session status constants\r\nexport const SESSION_STATUS = {\r\n    SCHEDULED: 'scheduled',\r\n    OPEN: 'open',\r\n    CLOSED: 'closed'\r\n};\r\n\r\n// Attendance status constants\r\nexport const ATTENDANCE_STATUS = {\r\n    PRESENT: 'present',\r\n    LATE: 'late',\r\n    ABSENT: 'absent'\r\n};\r\n\r\n// Late window in minutes (first 10 minutes after session start)\r\nexport const LATE_WINDOW_MINUTES = 10;\r\n\r\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\r\n// Helper function to convert Cameroon time to UTC\r\nconst cameroonToUTC = (date, hour, min) => {\r\n    const cameroonTime = new Date(date);\r\n    cameroonTime.setHours(hour, min, 0, 0);\r\n    // Cameroon is UTC+1, so subtract 1 hour to get UTC\r\n    return new Date(cameroonTime.getTime() - (1 * 60 * 60 * 1000));\r\n};\r\n\r\n// Helper function to convert UTC to Cameroon time\r\nconst utcToCameroon = (utcDate) => {\r\n    // Add 1 hour to UTC to get Cameroon time\r\n    return new Date(utcDate.getTime() + (1 * 60 * 60 * 1000));\r\n};\r\n\r\nexport const calculateSessionStatus = (session) => {\r\n    const now = new Date();\r\n\r\n    // Handle different property names (database vs transformed)\r\n    const sessionDate = session.session_date || session.date;\r\n    const startTime = session.start_time || session.startTime;\r\n    const endTime = session.end_time || session.endTime;\r\n\r\n    // Parse start and end times as Cameroon time, then convert to UTC for comparison\r\n    const [startHour, startMin] = startTime.split(':').map(Number);\r\n    const [endHour, endMin] = endTime.split(':').map(Number);\r\n\r\n    const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\r\n    const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\r\n\r\n    // Convert current time to UTC for comparison\r\n    const nowUTC = new Date(now.getTime() - (now.getTimezoneOffset() * 60 * 1000));\r\n\r\n    // Determine status\r\n    if (nowUTC < startDateTimeUTC) {\r\n        return SESSION_STATUS.SCHEDULED;\r\n    } else if (nowUTC >= startDateTimeUTC && nowUTC <= endDateTimeUTC) {\r\n        return SESSION_STATUS.OPEN;\r\n    } else {\r\n        return SESSION_STATUS.CLOSED;\r\n    }\r\n};\r\n\r\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\r\nexport const canMarkAttendance = async (session, studentId) => {\r\n    const status = calculateSessionStatus(session);\r\n\r\n    // Check if session is open\r\n    if (status === SESSION_STATUS.SCHEDULED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has not started yet',\r\n            status\r\n        };\r\n    }\r\n\r\n    if (status === SESSION_STATUS.CLOSED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has ended. Attendance is locked.',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student is enrolled in the course\r\n    const { data: classData, error: classError } = await supabase\r\n        .from('classes')\r\n        .select('course_id')\r\n        .eq('id', session.class_id)\r\n        .single();\r\n\r\n    if (classError || !classData) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Unable to verify enrollment',\r\n            status\r\n        };\r\n    }\r\n\r\n    const { data: enrollment, error: enrollError } = await supabase\r\n        .from('enrollments')\r\n        .select('id')\r\n        .eq('student_id', studentId)\r\n        .eq('course_id', classData.course_id)\r\n        .single();\r\n\r\n    if (enrollError || !enrollment) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You are not enrolled in this course',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student has already marked attendance\r\n    const { data: existingAttendance, error: attendanceError } = await supabase\r\n        .from('attendance')\r\n        .select('id')\r\n        .eq('session_id', session.id)\r\n        .eq('student_id', studentId)\r\n        .single();\r\n\r\n    if (existingAttendance) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You have already marked attendance for this session',\r\n            status\r\n        };\r\n    }\r\n\r\n    return {\r\n        canMark: true,\r\n        reason: 'Ready to mark attendance',\r\n        status\r\n    };\r\n};\r\n\r\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\r\nexport const isLateAttendance = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const lateThreshold = new Date(startDateTime);\r\n    lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\r\n\r\n    return now > lateThreshold;\r\n};\r\n\r\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\r\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\r\n    try {\r\n        // First get the session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, attendance: null, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if student can mark attendance\r\n        const { canMark, reason, status } = await canMarkAttendance(session, studentId);\r\n\r\n        if (!canMark) {\r\n            return { success: false, attendance: null, error: reason };\r\n        }\r\n\r\n        // Determine attendance status (present or late)\r\n        const attendanceStatus = isLateAttendance(session)\r\n            ? ATTENDANCE_STATUS.LATE\r\n            : ATTENDANCE_STATUS.PRESENT;\r\n\r\n        // Insert attendance record\r\n        const { data, error } = await supabase\r\n            .from('attendance')\r\n            .insert({\r\n                student_id: studentId,\r\n                session_id: sessionId,\r\n                status: attendanceStatus,\r\n                marked_at: new Date().toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) {\r\n            // Check for duplicate entry\r\n            if (error.code === '23505') {\r\n                return { success: false, attendance: null, error: 'Attendance already marked' };\r\n            }\r\n            throw error;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            attendance: data?.[0],\r\n            error: null,\r\n            status: attendanceStatus,\r\n            message: attendanceStatus === ATTENDANCE_STATUS.LATE\r\n                ? 'Attendance marked as LATE'\r\n                : 'Attendance marked successfully!'\r\n        };\r\n    } catch (error) {\r\n        console.error('Error marking attendance:', error);\r\n        return { success: false, attendance: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\r\nexport const autoMarkAbsentStudents = async (sessionId) => {\r\n    try {\r\n        // Get session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*, classes!inner(course_id)')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, absentCount: 0, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if session is closed\r\n        const status = calculateSessionStatus(session);\r\n        if (status !== SESSION_STATUS.CLOSED) {\r\n            return { success: false, absentCount: 0, error: 'Session is not closed yet' };\r\n        }\r\n\r\n        // Get all enrolled students for this course\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('student_id')\r\n            .eq('course_id', session.classes.course_id);\r\n\r\n        if (enrollError) {\r\n            throw enrollError;\r\n        }\r\n\r\n        // Get students who already marked attendance\r\n        const { data: presentStudents, error: presentError } = await supabase\r\n            .from('attendance')\r\n            .select('student_id')\r\n            .eq('session_id', sessionId);\r\n\r\n        if (presentError) {\r\n            throw presentError;\r\n        }\r\n\r\n        const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\r\n\r\n        // Find students who didn't mark attendance\r\n        const absentStudents = (enrollments || [])\r\n            .filter(e => !presentStudentIds.has(e.student_id))\r\n            .map(e => ({\r\n                student_id: e.student_id,\r\n                session_id: sessionId,\r\n                status: ATTENDANCE_STATUS.ABSENT,\r\n                marked_at: new Date().toISOString()\r\n            }));\r\n\r\n        if (absentStudents.length === 0) {\r\n            return { success: true, absentCount: 0, error: null };\r\n        }\r\n\r\n        // Insert absent records\r\n        const { error: insertError } = await supabase\r\n            .from('attendance')\r\n            .insert(absentStudents);\r\n\r\n        if (insertError) {\r\n            throw insertError;\r\n        }\r\n\r\n        return { success: true, absentCount: absentStudents.length, error: null };\r\n    } catch (error) {\r\n        console.error('Error auto-marking absent students:', error);\r\n        return { success: false, absentCount: 0, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\r\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\r\n    try {\r\n        let query = supabase\r\n            .from('sessions')\r\n            .select('id, start_time, end_time')\r\n            .eq('class_id', classId)\r\n            .eq('session_date', date);\r\n\r\n        if (excludeSessionId) {\r\n            query = query.neq('id', excludeSessionId);\r\n        }\r\n\r\n        const { data: sessions, error } = await query;\r\n\r\n        if (error) {\r\n            throw error;\r\n        }\r\n\r\n        // Check for time overlaps\r\n        const overlapping = (sessions || []).filter(session => {\r\n            const existingStart = session.start_time;\r\n            const existingEnd = session.end_time;\r\n\r\n            // Check if times overlap\r\n            return (startTime < existingEnd && endTime > existingStart);\r\n        });\r\n\r\n        return {\r\n            hasOverlap: overlapping.length > 0,\r\n            overlappingSessions: overlapping\r\n        };\r\n    } catch (error) {\r\n        console.error('Error checking overlapping sessions:', error);\r\n        return { hasOverlap: false, overlappingSessions: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\r\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\r\n    try {\r\n        // Check for overlapping sessions\r\n        const { hasOverlap, overlappingSessions } = await checkOverlappingSessions(\r\n            classId, sessionDate, startTime, endTime\r\n        );\r\n\r\n        if (hasOverlap) {\r\n            return {\r\n                session: null,\r\n                error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\r\n            };\r\n        }\r\n\r\n        // Generate a unique token\r\n        const token = Math.random().toString(36).substring(2, 15) +\r\n            Math.random().toString(36).substring(2, 15);\r\n\r\n        // Calculate expires_at (same as end time for automatic closure) in UTC\r\n        const [endHour, endMin] = endTime.split(':');\r\n        const expiresAt = cameroonToUTC(sessionDate, parseInt(endHour), parseInt(endMin));\r\n\r\n        const { data, error } = await supabase\r\n            .from('sessions')\r\n            .insert({\r\n                class_id: classId,\r\n                session_date: sessionDate,\r\n                start_time: startTime,\r\n                end_time: endTime,\r\n                token,\r\n                expires_at: expiresAt.toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) throw error;\r\n\r\n        return { session: data?.[0], error: null };\r\n    } catch (error) {\r\n        console.error('Error creating session:', error);\r\n        return { session: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getStudentSessionsByStatus = async (studentId) => {\r\n    try {\r\n        // Get student's enrolled courses\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('course_id')\r\n            .eq('student_id', studentId);\r\n\r\n        if (enrollError) throw enrollError;\r\n\r\n        const courseIds = (enrollments || []).map(e => e.course_id);\r\n\r\n        // Get classes for these courses\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .in('course_id', courseIds);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get student's attendance records\r\n        const { data: attendance, error: attendanceError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id, status')\r\n            .eq('student_id', studentId);\r\n\r\n        if (attendanceError) throw attendanceError;\r\n\r\n        const attendanceMap = new Map(\r\n            (attendance || []).map(a => [a.session_id, a.status])\r\n        );\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n            const isMarked = attendanceMap.has(session.id);\r\n            const attendanceStatus = attendanceMap.get(session.id);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                isMarked,\r\n                attendanceStatus,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching student sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getDelegateSessionsByStatus = async (delegateId) => {\r\n    try {\r\n        // Get delegate's classes\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .eq('delegate_id', delegateId);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get attendance counts for each session\r\n        const sessionIds = (sessions || []).map(s => s.id);\r\n        const { data: attendanceCounts, error: countError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id')\r\n            .in('session_id', sessionIds);\r\n\r\n        // Count attendance per session\r\n        const countMap = new Map();\r\n        (attendanceCounts || []).forEach(a => {\r\n            countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\r\n        });\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                attendanceCount: countMap.get(session.id) || 0,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching delegate sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\r\nexport const processSessionClosure = async (sessionId) => {\r\n    try {\r\n        // Auto-mark absent students\r\n        const result = await autoMarkAbsentStudents(sessionId);\r\n\r\n        if (!result.success) {\r\n            console.error('Failed to auto-mark absent students:', result.error);\r\n        } else {\r\n            console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\r\n        }\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error processing session closure:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\r\nexport const getTimeRemaining = (session) => {\r\n    const now = new Date();\r\n\r\n    // Handle different property names\r\n    const sessionDate = session.session_date || session.date;\r\n    const startTime = session.start_time || session.startTime;\r\n    const endTime = session.end_time || session.endTime;\r\n\r\n    const [startHour, startMin] = startTime.split(':').map(Number);\r\n    const [endHour, endMin] = endTime.split(':').map(Number);\r\n\r\n    const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\r\n    const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\r\n    const nowUTC = new Date(now.getTime() - (now.getTimezoneOffset() * 60 * 1000));\r\n\r\n    if (nowUTC < startDateTimeUTC) {\r\n        const diffMs = startDateTimeUTC - nowUTC;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'start',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\r\n        };\r\n    } else if (nowUTC < endDateTimeUTC) {\r\n        const diffMs = endDateTimeUTC - nowUTC;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'end',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\r\n        };\r\n    }\r\n\r\n    return {\r\n        type: 'ended',\r\n        minutes: 0,\r\n        formatted: 'Session ended'\r\n    };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}