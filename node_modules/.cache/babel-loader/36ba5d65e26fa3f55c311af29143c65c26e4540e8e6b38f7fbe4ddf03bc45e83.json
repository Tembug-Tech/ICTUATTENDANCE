{"ast":null,"code":"import _objectSpread from\"C:/Users/PFI/Desktop/ATTENDANCE/ATTENDANCE/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState,useEffect,useCallback,useRef}from'react';import{SESSION_STATUS,calculateSessionStatus,getStudentSessionsByStatus,getDelegateSessionsByStatus,markAttendanceWithStatus,processSessionClosure,getTimeRemaining}from'../utils/sessionLifecycle';/**\r\n * Custom hook for managing session lifecycle with real-time updates\r\n * Automatically updates session statuses based on time\r\n * \r\n * @param {string} userId - User's ID\r\n * @param {string} role - User's role ('student' or 'delegate')\r\n * @param {number} refreshInterval - Interval in ms for checking status updates (default: 10000)\r\n */export const useSessionLifecycle=function(userId,role){let refreshInterval=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10000;const[sessions,setSessions]=useState({scheduled:[],open:[],closed:[]});const[loading,setLoading]=useState(true);const[error,setError]=useState(null);const[lastUpdate,setLastUpdate]=useState(null);// Track sessions that have transitioned to closed for processing\nconst processedClosures=useRef(new Set());// Fetch sessions based on role\nconst fetchSessions=useCallback(async()=>{if(!userId)return;try{setLoading(true);setError(null);let result;if(role==='student'){result=await getStudentSessionsByStatus(userId);}else if(role==='delegate'){result=await getDelegateSessionsByStatus(userId);}else{throw new Error('Invalid role');}if(result.error){throw new Error(result.error);}setSessions({scheduled:result.scheduled||[],open:result.open||[],closed:result.closed||[]});setLastUpdate(new Date());}catch(err){console.error('Error fetching sessions:',err);setError(err.message);}finally{setLoading(false);}},[userId,role]);// Check for status transitions and update accordingly\nconst checkStatusTransitions=useCallback(()=>{const now=new Date();let hasChanges=false;// Check scheduled sessions that should now be open\nconst newScheduled=[];const newOpen=[...sessions.open];for(const session of sessions.scheduled){const currentStatus=calculateSessionStatus({session_date:session.date,start_time:session.startTime,end_time:session.endTime});if(currentStatus===SESSION_STATUS.OPEN){newOpen.push(_objectSpread(_objectSpread({},session),{},{status:SESSION_STATUS.OPEN}));hasChanges=true;}else{newScheduled.push(session);}}// Check open sessions that should now be closed\nconst newClosed=[...sessions.closed];const stillOpen=[];for(const session of newOpen){const currentStatus=calculateSessionStatus({session_date:session.date,start_time:session.startTime,end_time:session.endTime});if(currentStatus===SESSION_STATUS.CLOSED){newClosed.push(_objectSpread(_objectSpread({},session),{},{status:SESSION_STATUS.CLOSED}));hasChanges=true;// Process session closure (auto-mark absent) if not already processed\nif(!processedClosures.current.has(session.id)){processedClosures.current.add(session.id);processSessionClosure(session.id).catch(console.error);}}else{stillOpen.push(session);}}if(hasChanges){setSessions({scheduled:newScheduled,open:stillOpen,closed:newClosed});setLastUpdate(new Date());}},[sessions]);// Initial fetch\nuseEffect(()=>{fetchSessions();},[fetchSessions]);// Set up interval for checking status transitions\nuseEffect(()=>{const interval=setInterval(()=>{checkStatusTransitions();},refreshInterval);return()=>clearInterval(interval);},[checkStatusTransitions,refreshInterval]);// Refresh data periodically (every 30 seconds)\nuseEffect(()=>{const interval=setInterval(()=>{fetchSessions();},30000);return()=>clearInterval(interval);},[fetchSessions]);// Mark attendance function\nconst markAttendance=useCallback(async sessionId=>{if(!userId){return{success:false,error:'User not authenticated'};}const result=await markAttendanceWithStatus(userId,sessionId);if(result.success){// Update local state to reflect the change\nsetSessions(prev=>_objectSpread(_objectSpread({},prev),{},{open:prev.open.map(s=>s.id===sessionId?_objectSpread(_objectSpread({},s),{},{isMarked:true,attendanceStatus:result.status}):s)}));}return result;},[userId]);// Get time remaining for a session\nconst getSessionTimeRemaining=useCallback(session=>{return getTimeRemaining({session_date:session.date,start_time:session.startTime,end_time:session.endTime});},[]);// Get all active sessions (open sessions)\nconst activeSessions=sessions.open;// Get upcoming sessions (scheduled)\nconst upcomingSessions=sessions.scheduled;// Get past sessions (closed)\nconst pastSessions=sessions.closed;// Get sessions that need attention (open but not marked for students)\nconst sessionsNeedingAttention=role==='student'?sessions.open.filter(s=>!s.isMarked):sessions.open;return{sessions,activeSessions,upcomingSessions,pastSessions,sessionsNeedingAttention,loading,error,lastUpdate,refresh:fetchSessions,markAttendance,getSessionTimeRemaining};};/**\r\n * Custom hook for countdown timer\r\n * @param {Object} session - Session object\r\n * @param {number} updateInterval - Update interval in ms (default: 1000)\r\n */export const useSessionCountdown=function(session){let updateInterval=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1000;const[timeRemaining,setTimeRemaining]=useState(null);useEffect(()=>{if(!session)return;const updateTime=()=>{const remaining=getTimeRemaining({session_date:session.date||session.session_date,start_time:session.startTime||session.start_time,end_time:session.endTime||session.end_time});setTimeRemaining(remaining);};updateTime();const interval=setInterval(updateTime,updateInterval);return()=>clearInterval(interval);},[session,updateInterval]);return timeRemaining;};/**\r\n * Custom hook for real-time session status\r\n * @param {Object} session - Session object\r\n */export const useSessionStatus=session=>{const[status,setStatus]=useState(null);useEffect(()=>{if(!session)return;const updateStatus=()=>{const currentStatus=calculateSessionStatus({session_date:session.date||session.session_date,start_time:session.startTime||session.start_time,end_time:session.endTime||session.end_time});setStatus(currentStatus);};updateStatus();const interval=setInterval(updateStatus,5000);return()=>clearInterval(interval);},[session]);return status;};export default useSessionLifecycle;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","SESSION_STATUS","calculateSessionStatus","getStudentSessionsByStatus","getDelegateSessionsByStatus","markAttendanceWithStatus","processSessionClosure","getTimeRemaining","useSessionLifecycle","userId","role","refreshInterval","arguments","length","undefined","sessions","setSessions","scheduled","open","closed","loading","setLoading","error","setError","lastUpdate","setLastUpdate","processedClosures","Set","fetchSessions","result","Error","Date","err","console","message","checkStatusTransitions","now","hasChanges","newScheduled","newOpen","session","currentStatus","session_date","date","start_time","startTime","end_time","endTime","OPEN","push","_objectSpread","status","newClosed","stillOpen","CLOSED","current","has","id","add","catch","interval","setInterval","clearInterval","markAttendance","sessionId","success","prev","map","s","isMarked","attendanceStatus","getSessionTimeRemaining","activeSessions","upcomingSessions","pastSessions","sessionsNeedingAttention","filter","refresh","useSessionCountdown","updateInterval","timeRemaining","setTimeRemaining","updateTime","remaining","useSessionStatus","setStatus","updateStatus"],"sources":["C:/Users/PFI/Desktop/ATTENDANCE/ATTENDANCE/src/hooks/useSessionLifecycle.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n    SESSION_STATUS,\r\n    calculateSessionStatus,\r\n    getStudentSessionsByStatus,\r\n    getDelegateSessionsByStatus,\r\n    markAttendanceWithStatus,\r\n    processSessionClosure,\r\n    getTimeRemaining\r\n} from '../utils/sessionLifecycle';\r\n\r\n/**\r\n * Custom hook for managing session lifecycle with real-time updates\r\n * Automatically updates session statuses based on time\r\n * \r\n * @param {string} userId - User's ID\r\n * @param {string} role - User's role ('student' or 'delegate')\r\n * @param {number} refreshInterval - Interval in ms for checking status updates (default: 10000)\r\n */\r\nexport const useSessionLifecycle = (userId, role, refreshInterval = 10000) => {\r\n    const [sessions, setSessions] = useState({\r\n        scheduled: [],\r\n        open: [],\r\n        closed: []\r\n    });\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState(null);\r\n    const [lastUpdate, setLastUpdate] = useState(null);\r\n\r\n    // Track sessions that have transitioned to closed for processing\r\n    const processedClosures = useRef(new Set());\r\n\r\n    // Fetch sessions based on role\r\n    const fetchSessions = useCallback(async () => {\r\n        if (!userId) return;\r\n\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n\r\n            let result;\r\n            if (role === 'student') {\r\n                result = await getStudentSessionsByStatus(userId);\r\n            } else if (role === 'delegate') {\r\n                result = await getDelegateSessionsByStatus(userId);\r\n            } else {\r\n                throw new Error('Invalid role');\r\n            }\r\n\r\n            if (result.error) {\r\n                throw new Error(result.error);\r\n            }\r\n\r\n            setSessions({\r\n                scheduled: result.scheduled || [],\r\n                open: result.open || [],\r\n                closed: result.closed || []\r\n            });\r\n            setLastUpdate(new Date());\r\n        } catch (err) {\r\n            console.error('Error fetching sessions:', err);\r\n            setError(err.message);\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    }, [userId, role]);\r\n\r\n    // Check for status transitions and update accordingly\r\n    const checkStatusTransitions = useCallback(() => {\r\n        const now = new Date();\r\n        let hasChanges = false;\r\n\r\n        // Check scheduled sessions that should now be open\r\n        const newScheduled = [];\r\n        const newOpen = [...sessions.open];\r\n\r\n        for (const session of sessions.scheduled) {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date,\r\n                start_time: session.startTime,\r\n                end_time: session.endTime\r\n            });\r\n\r\n            if (currentStatus === SESSION_STATUS.OPEN) {\r\n                newOpen.push({ ...session, status: SESSION_STATUS.OPEN });\r\n                hasChanges = true;\r\n            } else {\r\n                newScheduled.push(session);\r\n            }\r\n        }\r\n\r\n        // Check open sessions that should now be closed\r\n        const newClosed = [...sessions.closed];\r\n        const stillOpen = [];\r\n\r\n        for (const session of newOpen) {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date,\r\n                start_time: session.startTime,\r\n                end_time: session.endTime\r\n            });\r\n\r\n            if (currentStatus === SESSION_STATUS.CLOSED) {\r\n                newClosed.push({ ...session, status: SESSION_STATUS.CLOSED });\r\n                hasChanges = true;\r\n\r\n                // Process session closure (auto-mark absent) if not already processed\r\n                if (!processedClosures.current.has(session.id)) {\r\n                    processedClosures.current.add(session.id);\r\n                    processSessionClosure(session.id).catch(console.error);\r\n                }\r\n            } else {\r\n                stillOpen.push(session);\r\n            }\r\n        }\r\n\r\n        if (hasChanges) {\r\n            setSessions({\r\n                scheduled: newScheduled,\r\n                open: stillOpen,\r\n                closed: newClosed\r\n            });\r\n            setLastUpdate(new Date());\r\n        }\r\n    }, [sessions]);\r\n\r\n    // Initial fetch\r\n    useEffect(() => {\r\n        fetchSessions();\r\n    }, [fetchSessions]);\r\n\r\n    // Set up interval for checking status transitions\r\n    useEffect(() => {\r\n        const interval = setInterval(() => {\r\n            checkStatusTransitions();\r\n        }, refreshInterval);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [checkStatusTransitions, refreshInterval]);\r\n\r\n    // Refresh data periodically (every 30 seconds)\r\n    useEffect(() => {\r\n        const interval = setInterval(() => {\r\n            fetchSessions();\r\n        }, 30000);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [fetchSessions]);\r\n\r\n    // Mark attendance function\r\n    const markAttendance = useCallback(async (sessionId) => {\r\n        if (!userId) {\r\n            return { success: false, error: 'User not authenticated' };\r\n        }\r\n\r\n        const result = await markAttendanceWithStatus(userId, sessionId);\r\n\r\n        if (result.success) {\r\n            // Update local state to reflect the change\r\n            setSessions(prev => ({\r\n                ...prev,\r\n                open: prev.open.map(s =>\r\n                    s.id === sessionId\r\n                        ? { ...s, isMarked: true, attendanceStatus: result.status }\r\n                        : s\r\n                )\r\n            }));\r\n        }\r\n\r\n        return result;\r\n    }, [userId]);\r\n\r\n    // Get time remaining for a session\r\n    const getSessionTimeRemaining = useCallback((session) => {\r\n        return getTimeRemaining({\r\n            session_date: session.date,\r\n            start_time: session.startTime,\r\n            end_time: session.endTime\r\n        });\r\n    }, []);\r\n\r\n    // Get all active sessions (open sessions)\r\n    const activeSessions = sessions.open;\r\n\r\n    // Get upcoming sessions (scheduled)\r\n    const upcomingSessions = sessions.scheduled;\r\n\r\n    // Get past sessions (closed)\r\n    const pastSessions = sessions.closed;\r\n\r\n    // Get sessions that need attention (open but not marked for students)\r\n    const sessionsNeedingAttention = role === 'student'\r\n        ? sessions.open.filter(s => !s.isMarked)\r\n        : sessions.open;\r\n\r\n    return {\r\n        sessions,\r\n        activeSessions,\r\n        upcomingSessions,\r\n        pastSessions,\r\n        sessionsNeedingAttention,\r\n        loading,\r\n        error,\r\n        lastUpdate,\r\n        refresh: fetchSessions,\r\n        markAttendance,\r\n        getSessionTimeRemaining\r\n    };\r\n};\r\n\r\n/**\r\n * Custom hook for countdown timer\r\n * @param {Object} session - Session object\r\n * @param {number} updateInterval - Update interval in ms (default: 1000)\r\n */\r\nexport const useSessionCountdown = (session, updateInterval = 1000) => {\r\n    const [timeRemaining, setTimeRemaining] = useState(null);\r\n\r\n    useEffect(() => {\r\n        if (!session) return;\r\n\r\n        const updateTime = () => {\r\n            const remaining = getTimeRemaining({\r\n                session_date: session.date || session.session_date,\r\n                start_time: session.startTime || session.start_time,\r\n                end_time: session.endTime || session.end_time\r\n            });\r\n            setTimeRemaining(remaining);\r\n        };\r\n\r\n        updateTime();\r\n        const interval = setInterval(updateTime, updateInterval);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [session, updateInterval]);\r\n\r\n    return timeRemaining;\r\n};\r\n\r\n/**\r\n * Custom hook for real-time session status\r\n * @param {Object} session - Session object\r\n */\r\nexport const useSessionStatus = (session) => {\r\n    const [status, setStatus] = useState(null);\r\n\r\n    useEffect(() => {\r\n        if (!session) return;\r\n\r\n        const updateStatus = () => {\r\n            const currentStatus = calculateSessionStatus({\r\n                session_date: session.date || session.session_date,\r\n                start_time: session.startTime || session.start_time,\r\n                end_time: session.endTime || session.end_time\r\n            });\r\n            setStatus(currentStatus);\r\n        };\r\n\r\n        updateStatus();\r\n        const interval = setInterval(updateStatus, 5000);\r\n\r\n        return () => clearInterval(interval);\r\n    }, [session]);\r\n\r\n    return status;\r\n};\r\n\r\nexport default useSessionLifecycle;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}