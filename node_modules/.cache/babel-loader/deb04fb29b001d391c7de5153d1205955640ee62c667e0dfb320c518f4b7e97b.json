{"ast":null,"code":"/**\r\n * GPS Utilities for Geofence-Based Attendance System\r\n * Implements Haversine formula and geofence validation\r\n */\n\n/**\r\n * Calculate distance between two geographic points using Haversine formula\r\n * @param {number} lat1 - Student latitude\r\n * @param {number} lon1 - Student longitude\r\n * @param {number} lat2 - Campus center latitude\r\n * @param {number} lon2 - Campus center longitude\r\n * @returns {number} Distance in meters\r\n */\nexport const calculateHaversineDistance = (lat1, lon1, lat2, lon2) => {\n  const EARTH_RADIUS_METERS = 6371000; // Earth radius in meters\n\n  const toRad = value => value * Math.PI / 180;\n  const deltaLat = toRad(lat2 - lat1);\n  const deltaLon = toRad(lon2 - lon1);\n  const a = Math.sin(deltaLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(deltaLon / 2) ** 2;\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const distance = EARTH_RADIUS_METERS * c;\n  return Math.round(distance * 100) / 100; // Round to 2 decimal places\n};\n\n/**\r\n * Validate GPS accuracy\r\n * @param {number} accuracy - GPS accuracy in meters\r\n * @param {number} maxAccuracy - Maximum allowed accuracy in meters\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\nexport const validateGPSAccuracy = (accuracy, maxAccuracy = 50) => {\n  if (accuracy === null || accuracy === undefined) {\n    return {\n      isValid: false,\n      reason: 'GPS accuracy not available'\n    };\n  }\n  if (accuracy > maxAccuracy) {\n    return {\n      isValid: false,\n      reason: `GPS signal too weak (accuracy: ${accuracy.toFixed(1)}m, required: ≤${maxAccuracy}m)`\n    };\n  }\n  return {\n    isValid: true\n  };\n};\n\n/**\r\n * Validate if student is within geofence\r\n * @param {number} distance - Distance from campus center in meters\r\n * @param {number} radius - Geofence radius in meters\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\nexport const validateGeofence = (distance, radius = 200) => {\n  if (distance === null || distance === undefined) {\n    return {\n      isValid: false,\n      reason: 'Distance calculation failed'\n    };\n  }\n  if (distance > radius) {\n    return {\n      isValid: false,\n      reason: `Outside campus boundary (${distance.toFixed(1)}m away, allowed: ≤${radius}m)`\n    };\n  }\n  return {\n    isValid: true\n  };\n};\n\n/**\r\n * Comprehensive GPS validation\r\n * @param {Object} gpsData - { latitude, longitude, accuracy }\r\n * @param {Object} campusData - { latitude, longitude, radius, maxAccuracy }\r\n * @returns {Object} Validation result with all details\r\n */\nexport const validateGPSLocation = (gpsData, campusData) => {\n  const {\n    latitude,\n    longitude,\n    accuracy\n  } = gpsData;\n  const {\n    latitude: campusLat,\n    longitude: campusLon,\n    radius_meters = 200,\n    max_gps_accuracy_meters = 50\n  } = campusData;\n\n  // Validate inputs\n  if (typeof latitude !== 'number' || typeof longitude !== 'number' || typeof accuracy !== 'number') {\n    return {\n      isValid: false,\n      reason: 'Invalid GPS data format',\n      accuracyCheck: {\n        passed: false\n      },\n      geofenceCheck: {\n        passed: false\n      }\n    };\n  }\n\n  // Check GPS accuracy first\n  const accuracyValidation = validateGPSAccuracy(accuracy, max_gps_accuracy_meters);\n  if (!accuracyValidation.isValid) {\n    return {\n      isValid: false,\n      reason: accuracyValidation.reason,\n      accuracyCheck: {\n        passed: false,\n        accuracy,\n        threshold: max_gps_accuracy_meters\n      },\n      geofenceCheck: {\n        passed: false\n      }\n    };\n  }\n\n  // Calculate distance\n  const distance = calculateHaversineDistance(latitude, longitude, campusLat, campusLon);\n\n  // Check geofence\n  const geofenceValidation = validateGeofence(distance, radius_meters);\n  if (!geofenceValidation.isValid) {\n    return {\n      isValid: false,\n      reason: geofenceValidation.reason,\n      accuracyCheck: {\n        passed: true,\n        accuracy\n      },\n      geofenceCheck: {\n        passed: false,\n        distance,\n        radius: radius_meters\n      }\n    };\n  }\n  return {\n    isValid: true,\n    reason: 'GPS validation successful',\n    accuracyCheck: {\n      passed: true,\n      accuracy\n    },\n    geofenceCheck: {\n      passed: true,\n      distance,\n      radius: radius_meters\n    },\n    studentLocation: {\n      latitude,\n      longitude\n    }\n  };\n};\n\n/**\r\n * Check if current time is within class time window\r\n * @param {string} classStartTime - HH:MM:SS format (e.g., \"14:00:00\")\r\n * @param {string} classEndTime - HH:MM:SS format (e.g., \"16:00:00\")\r\n * @param {Date} currentTime - Optional, defaults to now\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\nexport const validateClassTime = (classStartTime, classEndTime, currentTime = new Date()) => {\n  if (!classStartTime || !classEndTime) {\n    return {\n      isValid: true\n    }; // No time restriction if not set\n  }\n  const timeStr = currentTime.toLocaleTimeString('en-US', {\n    hour12: false,\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit'\n  });\n\n  // Simple string comparison works for HH:MM:SS format\n  if (timeStr >= classStartTime && timeStr <= classEndTime) {\n    return {\n      isValid: true\n    };\n  }\n  return {\n    isValid: false,\n    reason: `Outside class time window (${classStartTime}-${classEndTime}, current: ${timeStr})`\n  };\n};\n\n/**\r\n * Format GPS validation result for user display\r\n * @param {Object} result - Result from validateGPSLocation\r\n * @returns {string} User-friendly message\r\n */\nexport const formatGPSValidationMessage = result => {\n  if (result.isValid) {\n    const {\n      distance,\n      accuracy\n    } = result.geofenceCheck;\n    return `✓ Location verified (${distance.toFixed(0)}m away, accuracy: ${accuracy.toFixed(0)}m)`;\n  }\n  return result.reason || 'GPS validation failed';\n};","map":{"version":3,"names":["calculateHaversineDistance","lat1","lon1","lat2","lon2","EARTH_RADIUS_METERS","toRad","value","Math","PI","deltaLat","deltaLon","a","sin","cos","c","atan2","sqrt","distance","round","validateGPSAccuracy","accuracy","maxAccuracy","undefined","isValid","reason","toFixed","validateGeofence","radius","validateGPSLocation","gpsData","campusData","latitude","longitude","campusLat","campusLon","radius_meters","max_gps_accuracy_meters","accuracyCheck","passed","geofenceCheck","accuracyValidation","threshold","geofenceValidation","studentLocation","validateClassTime","classStartTime","classEndTime","currentTime","Date","timeStr","toLocaleTimeString","hour12","hour","minute","second","formatGPSValidationMessage","result"],"sources":["C:/Users/PFI/Desktop/ATTENDANCE/ATTENDANCE/src/utils/gpsUtils.js"],"sourcesContent":["/**\r\n * GPS Utilities for Geofence-Based Attendance System\r\n * Implements Haversine formula and geofence validation\r\n */\r\n\r\n/**\r\n * Calculate distance between two geographic points using Haversine formula\r\n * @param {number} lat1 - Student latitude\r\n * @param {number} lon1 - Student longitude\r\n * @param {number} lat2 - Campus center latitude\r\n * @param {number} lon2 - Campus center longitude\r\n * @returns {number} Distance in meters\r\n */\r\nexport const calculateHaversineDistance = (lat1, lon1, lat2, lon2) => {\r\n  const EARTH_RADIUS_METERS = 6371000; // Earth radius in meters\r\n\r\n  const toRad = (value) => (value * Math.PI) / 180;\r\n  const deltaLat = toRad(lat2 - lat1);\r\n  const deltaLon = toRad(lon2 - lon1);\r\n\r\n  const a =\r\n    Math.sin(deltaLat / 2) ** 2 +\r\n    Math.cos(toRad(lat1)) *\r\n      Math.cos(toRad(lat2)) *\r\n      Math.sin(deltaLon / 2) ** 2;\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  const distance = EARTH_RADIUS_METERS * c;\r\n\r\n  return Math.round(distance * 100) / 100; // Round to 2 decimal places\r\n};\r\n\r\n/**\r\n * Validate GPS accuracy\r\n * @param {number} accuracy - GPS accuracy in meters\r\n * @param {number} maxAccuracy - Maximum allowed accuracy in meters\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\r\nexport const validateGPSAccuracy = (accuracy, maxAccuracy = 50) => {\r\n  if (accuracy === null || accuracy === undefined) {\r\n    return { isValid: false, reason: 'GPS accuracy not available' };\r\n  }\r\n\r\n  if (accuracy > maxAccuracy) {\r\n    return {\r\n      isValid: false,\r\n      reason: `GPS signal too weak (accuracy: ${accuracy.toFixed(1)}m, required: ≤${maxAccuracy}m)`,\r\n    };\r\n  }\r\n\r\n  return { isValid: true };\r\n};\r\n\r\n/**\r\n * Validate if student is within geofence\r\n * @param {number} distance - Distance from campus center in meters\r\n * @param {number} radius - Geofence radius in meters\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\r\nexport const validateGeofence = (distance, radius = 200) => {\r\n  if (distance === null || distance === undefined) {\r\n    return { isValid: false, reason: 'Distance calculation failed' };\r\n  }\r\n\r\n  if (distance > radius) {\r\n    return {\r\n      isValid: false,\r\n      reason: `Outside campus boundary (${distance.toFixed(1)}m away, allowed: ≤${radius}m)`,\r\n    };\r\n  }\r\n\r\n  return { isValid: true };\r\n};\r\n\r\n/**\r\n * Comprehensive GPS validation\r\n * @param {Object} gpsData - { latitude, longitude, accuracy }\r\n * @param {Object} campusData - { latitude, longitude, radius, maxAccuracy }\r\n * @returns {Object} Validation result with all details\r\n */\r\nexport const validateGPSLocation = (gpsData, campusData) => {\r\n  const { latitude, longitude, accuracy } = gpsData;\r\n  const {\r\n    latitude: campusLat,\r\n    longitude: campusLon,\r\n    radius_meters = 200,\r\n    max_gps_accuracy_meters = 50,\r\n  } = campusData;\r\n\r\n  // Validate inputs\r\n  if (\r\n    typeof latitude !== 'number' ||\r\n    typeof longitude !== 'number' ||\r\n    typeof accuracy !== 'number'\r\n  ) {\r\n    return {\r\n      isValid: false,\r\n      reason: 'Invalid GPS data format',\r\n      accuracyCheck: { passed: false },\r\n      geofenceCheck: { passed: false },\r\n    };\r\n  }\r\n\r\n  // Check GPS accuracy first\r\n  const accuracyValidation = validateGPSAccuracy(accuracy, max_gps_accuracy_meters);\r\n  if (!accuracyValidation.isValid) {\r\n    return {\r\n      isValid: false,\r\n      reason: accuracyValidation.reason,\r\n      accuracyCheck: { passed: false, accuracy, threshold: max_gps_accuracy_meters },\r\n      geofenceCheck: { passed: false },\r\n    };\r\n  }\r\n\r\n  // Calculate distance\r\n  const distance = calculateHaversineDistance(\r\n    latitude,\r\n    longitude,\r\n    campusLat,\r\n    campusLon\r\n  );\r\n\r\n  // Check geofence\r\n  const geofenceValidation = validateGeofence(distance, radius_meters);\r\n  if (!geofenceValidation.isValid) {\r\n    return {\r\n      isValid: false,\r\n      reason: geofenceValidation.reason,\r\n      accuracyCheck: { passed: true, accuracy },\r\n      geofenceCheck: { passed: false, distance, radius: radius_meters },\r\n    };\r\n  }\r\n\r\n  return {\r\n    isValid: true,\r\n    reason: 'GPS validation successful',\r\n    accuracyCheck: { passed: true, accuracy },\r\n    geofenceCheck: { passed: true, distance, radius: radius_meters },\r\n    studentLocation: { latitude, longitude },\r\n  };\r\n};\r\n\r\n/**\r\n * Check if current time is within class time window\r\n * @param {string} classStartTime - HH:MM:SS format (e.g., \"14:00:00\")\r\n * @param {string} classEndTime - HH:MM:SS format (e.g., \"16:00:00\")\r\n * @param {Date} currentTime - Optional, defaults to now\r\n * @returns {Object} { isValid: boolean, reason?: string }\r\n */\r\nexport const validateClassTime = (classStartTime, classEndTime, currentTime = new Date()) => {\r\n  if (!classStartTime || !classEndTime) {\r\n    return { isValid: true }; // No time restriction if not set\r\n  }\r\n\r\n  const timeStr = currentTime.toLocaleTimeString('en-US', {\r\n    hour12: false,\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n    second: '2-digit',\r\n  });\r\n\r\n  // Simple string comparison works for HH:MM:SS format\r\n  if (timeStr >= classStartTime && timeStr <= classEndTime) {\r\n    return { isValid: true };\r\n  }\r\n\r\n  return {\r\n    isValid: false,\r\n    reason: `Outside class time window (${classStartTime}-${classEndTime}, current: ${timeStr})`,\r\n  };\r\n};\r\n\r\n/**\r\n * Format GPS validation result for user display\r\n * @param {Object} result - Result from validateGPSLocation\r\n * @returns {string} User-friendly message\r\n */\r\nexport const formatGPSValidationMessage = (result) => {\r\n  if (result.isValid) {\r\n    const { distance, accuracy } = result.geofenceCheck;\r\n    return `✓ Location verified (${distance.toFixed(0)}m away, accuracy: ${accuracy.toFixed(0)}m)`;\r\n  }\r\n\r\n  return result.reason || 'GPS validation failed';\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}