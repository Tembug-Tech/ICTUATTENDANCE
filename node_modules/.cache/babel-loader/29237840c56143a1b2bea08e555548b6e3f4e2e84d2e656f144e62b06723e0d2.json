{"ast":null,"code":"import { supabase } from '../supabase/supabase';\n\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\n\n// Session status constants\nexport const SESSION_STATUS = {\n  SCHEDULED: 'scheduled',\n  OPEN: 'open',\n  CLOSED: 'closed'\n};\n\n// Attendance status constants\nexport const ATTENDANCE_STATUS = {\n  PRESENT: 'present',\n  LATE: 'late',\n  ABSENT: 'absent'\n};\n\n// Late window in minutes (first 10 minutes after session start)\nexport const LATE_WINDOW_MINUTES = 10;\n\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\nexport const calculateSessionStatus = session => {\n  const now = new Date();\n  const sessionDate = session.session_date;\n\n  // Parse start and end times\n  const [startHour, startMin] = session.start_time.split(':').map(Number);\n  const [endHour, endMin] = session.end_time.split(':').map(Number);\n\n  // Create full datetime objects in local timezone\n  const startDateTime = new Date(sessionDate);\n  startDateTime.setHours(startHour, startMin, 0, 0);\n  const endDateTime = new Date(sessionDate);\n  endDateTime.setHours(endHour, endMin, 0, 0);\n\n  // Determine status based on local time\n  if (now < startDateTime) {\n    return SESSION_STATUS.SCHEDULED;\n  } else if (now >= startDateTime && now <= endDateTime) {\n    return SESSION_STATUS.OPEN;\n  } else {\n    return SESSION_STATUS.CLOSED;\n  }\n};\n\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\nexport const canMarkAttendance = async (session, studentId) => {\n  const status = calculateSessionStatus(session);\n\n  // Check if session is open\n  if (status === SESSION_STATUS.SCHEDULED) {\n    return {\n      canMark: false,\n      reason: 'Session has not started yet',\n      status\n    };\n  }\n  if (status === SESSION_STATUS.CLOSED) {\n    return {\n      canMark: false,\n      reason: 'Session has ended. Attendance is locked.',\n      status\n    };\n  }\n\n  // Check if student is enrolled in the course\n  const {\n    data: classData,\n    error: classError\n  } = await supabase.from('classes').select('course_id').eq('id', session.class_id).single();\n  if (classError || !classData) {\n    return {\n      canMark: false,\n      reason: 'Unable to verify enrollment',\n      status\n    };\n  }\n  const {\n    data: enrollment,\n    error: enrollError\n  } = await supabase.from('enrollments').select('id').eq('student_id', studentId).eq('course_id', classData.course_id).single();\n  if (enrollError || !enrollment) {\n    return {\n      canMark: false,\n      reason: 'You are not enrolled in this course',\n      status\n    };\n  }\n\n  // Check if student has already marked attendance\n  const {\n    data: existingAttendance,\n    error: attendanceError\n  } = await supabase.from('attendance').select('id').eq('session_id', session.id).eq('student_id', studentId).single();\n  if (existingAttendance) {\n    return {\n      canMark: false,\n      reason: 'You have already marked attendance for this session',\n      status\n    };\n  }\n  return {\n    canMark: true,\n    reason: 'Ready to mark attendance',\n    status\n  };\n};\n\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\nexport const isLateAttendance = session => {\n  const now = new Date();\n  const sessionDate = session.session_date;\n  const [startHour, startMin] = session.start_time.split(':').map(Number);\n  const startDateTime = new Date(sessionDate);\n  startDateTime.setHours(startHour, startMin, 0, 0);\n  const lateThreshold = new Date(startDateTime);\n  lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\n  return now > lateThreshold;\n};\n\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\n  try {\n    // First get the session details\n    const {\n      data: session,\n      error: sessionError\n    } = await supabase.from('sessions').select('*').eq('id', sessionId).single();\n    if (sessionError || !session) {\n      return {\n        success: false,\n        attendance: null,\n        error: 'Session not found'\n      };\n    }\n\n    // Check if student can mark attendance\n    const {\n      canMark,\n      reason,\n      status\n    } = await canMarkAttendance(session, studentId);\n    if (!canMark) {\n      return {\n        success: false,\n        attendance: null,\n        error: reason\n      };\n    }\n\n    // Determine attendance status (present or late)\n    const attendanceStatus = isLateAttendance(session) ? ATTENDANCE_STATUS.LATE : ATTENDANCE_STATUS.PRESENT;\n\n    // Insert attendance record\n    const {\n      data,\n      error\n    } = await supabase.from('attendance').insert({\n      student_id: studentId,\n      session_id: sessionId,\n      status: attendanceStatus,\n      marked_at: new Date().toISOString()\n    }).select();\n    if (error) {\n      // Check for duplicate entry\n      if (error.code === '23505') {\n        return {\n          success: false,\n          attendance: null,\n          error: 'Attendance already marked'\n        };\n      }\n      throw error;\n    }\n    return {\n      success: true,\n      attendance: data === null || data === void 0 ? void 0 : data[0],\n      error: null,\n      status: attendanceStatus,\n      message: attendanceStatus === ATTENDANCE_STATUS.LATE ? 'Attendance marked as LATE' : 'Attendance marked successfully!'\n    };\n  } catch (error) {\n    console.error('Error marking attendance:', error);\n    return {\n      success: false,\n      attendance: null,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\nexport const autoMarkAbsentStudents = async sessionId => {\n  try {\n    // Get session details\n    const {\n      data: session,\n      error: sessionError\n    } = await supabase.from('sessions').select('*, classes!inner(course_id)').eq('id', sessionId).single();\n    if (sessionError || !session) {\n      return {\n        success: false,\n        absentCount: 0,\n        error: 'Session not found'\n      };\n    }\n\n    // Check if session is closed\n    const status = calculateSessionStatus(session);\n    if (status !== SESSION_STATUS.CLOSED) {\n      return {\n        success: false,\n        absentCount: 0,\n        error: 'Session is not closed yet'\n      };\n    }\n\n    // Get all enrolled students for this course\n    const {\n      data: enrollments,\n      error: enrollError\n    } = await supabase.from('enrollments').select('student_id').eq('course_id', session.classes.course_id);\n    if (enrollError) {\n      throw enrollError;\n    }\n\n    // Get students who already marked attendance\n    const {\n      data: presentStudents,\n      error: presentError\n    } = await supabase.from('attendance').select('student_id').eq('session_id', sessionId);\n    if (presentError) {\n      throw presentError;\n    }\n    const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\n\n    // Find students who didn't mark attendance\n    const absentStudents = (enrollments || []).filter(e => !presentStudentIds.has(e.student_id)).map(e => ({\n      student_id: e.student_id,\n      session_id: sessionId,\n      status: ATTENDANCE_STATUS.ABSENT,\n      marked_at: new Date().toISOString()\n    }));\n    if (absentStudents.length === 0) {\n      return {\n        success: true,\n        absentCount: 0,\n        error: null\n      };\n    }\n\n    // Insert absent records\n    const {\n      error: insertError\n    } = await supabase.from('attendance').insert(absentStudents);\n    if (insertError) {\n      throw insertError;\n    }\n    return {\n      success: true,\n      absentCount: absentStudents.length,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error auto-marking absent students:', error);\n    return {\n      success: false,\n      absentCount: 0,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\n  try {\n    let query = supabase.from('sessions').select('id, start_time, end_time').eq('class_id', classId).eq('session_date', date);\n    if (excludeSessionId) {\n      query = query.neq('id', excludeSessionId);\n    }\n    const {\n      data: sessions,\n      error\n    } = await query;\n    if (error) {\n      throw error;\n    }\n\n    // Check for time overlaps\n    const overlapping = (sessions || []).filter(session => {\n      const existingStart = session.start_time;\n      const existingEnd = session.end_time;\n\n      // Check if times overlap\n      return startTime < existingEnd && endTime > existingStart;\n    });\n    return {\n      hasOverlap: overlapping.length > 0,\n      overlappingSessions: overlapping\n    };\n  } catch (error) {\n    console.error('Error checking overlapping sessions:', error);\n    return {\n      hasOverlap: false,\n      overlappingSessions: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\n  try {\n    // Check for overlapping sessions\n    const {\n      hasOverlap,\n      overlappingSessions\n    } = await checkOverlappingSessions(classId, sessionDate, startTime, endTime);\n    if (hasOverlap) {\n      return {\n        session: null,\n        error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\n      };\n    }\n\n    // Generate a unique token\n    const token = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n\n    // Calculate expires_at (same as end time for automatic closure) in Cameroon timezone\n    const expiresAt = new Date(sessionDate + 'T' + endTime + ':00+01:00');\n    const {\n      data,\n      error\n    } = await supabase.from('sessions').insert({\n      class_id: classId,\n      session_date: sessionDate,\n      start_time: startTime,\n      end_time: endTime,\n      token,\n      expires_at: expiresAt.toISOString()\n    }).select();\n    if (error) throw error;\n    return {\n      session: data === null || data === void 0 ? void 0 : data[0],\n      error: null\n    };\n  } catch (error) {\n    console.error('Error creating session:', error);\n    return {\n      session: null,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\nexport const getStudentSessionsByStatus = async studentId => {\n  try {\n    // Get student's enrolled courses\n    const {\n      data: enrollments,\n      error: enrollError\n    } = await supabase.from('enrollments').select('course_id').eq('student_id', studentId);\n    if (enrollError) throw enrollError;\n    const courseIds = (enrollments || []).map(e => e.course_id);\n\n    // Get classes for these courses\n    const {\n      data: classes,\n      error: classError\n    } = await supabase.from('classes').select('id').in('course_id', courseIds);\n    if (classError) throw classError;\n    const classIds = (classes || []).map(c => c.id);\n\n    // Get all sessions for these classes\n    const {\n      data: sessions,\n      error: sessionError\n    } = await supabase.from('sessions').select(`\n        id,\n        session_date,\n        start_time,\n        end_time,\n        token,\n        expires_at,\n        classes!inner (\n          id,\n          class_name,\n          courses!inner (course_code, course_title)\n        )\n      `).in('class_id', classIds).order('session_date', {\n      ascending: false\n    });\n    if (sessionError) throw sessionError;\n\n    // Get student's attendance records\n    const {\n      data: attendance,\n      error: attendanceError\n    } = await supabase.from('attendance').select('session_id, status').eq('student_id', studentId);\n    if (attendanceError) throw attendanceError;\n    const attendanceMap = new Map((attendance || []).map(a => [a.session_id, a.status]));\n\n    // Categorize sessions by status\n    const scheduled = [];\n    const open = [];\n    const closed = [];\n    for (const session of sessions || []) {\n      var _session$classes, _session$classes$cour, _session$classes2, _session$classes2$cou, _session$classes3;\n      const status = calculateSessionStatus(session);\n      const isMarked = attendanceMap.has(session.id);\n      const attendanceStatus = attendanceMap.get(session.id);\n      const enrichedSession = {\n        id: session.id,\n        courseCode: (_session$classes = session.classes) === null || _session$classes === void 0 ? void 0 : (_session$classes$cour = _session$classes.courses) === null || _session$classes$cour === void 0 ? void 0 : _session$classes$cour.course_code,\n        courseTitle: (_session$classes2 = session.classes) === null || _session$classes2 === void 0 ? void 0 : (_session$classes2$cou = _session$classes2.courses) === null || _session$classes2$cou === void 0 ? void 0 : _session$classes2$cou.course_title,\n        className: (_session$classes3 = session.classes) === null || _session$classes3 === void 0 ? void 0 : _session$classes3.class_name,\n        date: new Date(session.session_date).toLocaleDateString(),\n        startTime: session.start_time,\n        endTime: session.end_time,\n        status,\n        isMarked,\n        attendanceStatus,\n        token: session.token\n      };\n      switch (status) {\n        case SESSION_STATUS.SCHEDULED:\n          scheduled.push(enrichedSession);\n          break;\n        case SESSION_STATUS.OPEN:\n          open.push(enrichedSession);\n          break;\n        case SESSION_STATUS.CLOSED:\n          closed.push(enrichedSession);\n          break;\n      }\n    }\n    return {\n      scheduled,\n      open,\n      closed,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching student sessions:', error);\n    return {\n      scheduled: [],\n      open: [],\n      closed: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\nexport const getDelegateSessionsByStatus = async delegateId => {\n  try {\n    // Get delegate's classes\n    const {\n      data: classes,\n      error: classError\n    } = await supabase.from('classes').select('id').eq('delegate_id', delegateId);\n    if (classError) throw classError;\n    const classIds = (classes || []).map(c => c.id);\n\n    // Get all sessions for these classes\n    const {\n      data: sessions,\n      error: sessionError\n    } = await supabase.from('sessions').select(`\n        id,\n        session_date,\n        start_time,\n        end_time,\n        token,\n        expires_at,\n        classes!inner (\n          id,\n          class_name,\n          courses!inner (course_code, course_title)\n        )\n      `).in('class_id', classIds).order('session_date', {\n      ascending: false\n    });\n    if (sessionError) throw sessionError;\n\n    // Get attendance counts for each session\n    const sessionIds = (sessions || []).map(s => s.id);\n    const {\n      data: attendanceCounts,\n      error: countError\n    } = await supabase.from('attendance').select('session_id').in('session_id', sessionIds);\n\n    // Count attendance per session\n    const countMap = new Map();\n    (attendanceCounts || []).forEach(a => {\n      countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\n    });\n\n    // Categorize sessions by status\n    const scheduled = [];\n    const open = [];\n    const closed = [];\n    for (const session of sessions || []) {\n      var _session$classes4, _session$classes4$cou, _session$classes5, _session$classes5$cou, _session$classes6;\n      const status = calculateSessionStatus(session);\n      const enrichedSession = {\n        id: session.id,\n        courseCode: (_session$classes4 = session.classes) === null || _session$classes4 === void 0 ? void 0 : (_session$classes4$cou = _session$classes4.courses) === null || _session$classes4$cou === void 0 ? void 0 : _session$classes4$cou.course_code,\n        courseTitle: (_session$classes5 = session.classes) === null || _session$classes5 === void 0 ? void 0 : (_session$classes5$cou = _session$classes5.courses) === null || _session$classes5$cou === void 0 ? void 0 : _session$classes5$cou.course_title,\n        className: (_session$classes6 = session.classes) === null || _session$classes6 === void 0 ? void 0 : _session$classes6.class_name,\n        date: new Date(session.session_date).toLocaleDateString(),\n        startTime: session.start_time,\n        endTime: session.end_time,\n        status,\n        attendanceCount: countMap.get(session.id) || 0,\n        token: session.token\n      };\n      switch (status) {\n        case SESSION_STATUS.SCHEDULED:\n          scheduled.push(enrichedSession);\n          break;\n        case SESSION_STATUS.OPEN:\n          open.push(enrichedSession);\n          break;\n        case SESSION_STATUS.CLOSED:\n          closed.push(enrichedSession);\n          break;\n      }\n    }\n    return {\n      scheduled,\n      open,\n      closed,\n      error: null\n    };\n  } catch (error) {\n    console.error('Error fetching delegate sessions:', error);\n    return {\n      scheduled: [],\n      open: [],\n      closed: [],\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\nexport const processSessionClosure = async sessionId => {\n  try {\n    // Auto-mark absent students\n    const result = await autoMarkAbsentStudents(sessionId);\n    if (!result.success) {\n      console.error('Failed to auto-mark absent students:', result.error);\n    } else {\n      console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\n    }\n    return result;\n  } catch (error) {\n    console.error('Error processing session closure:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\nexport const getTimeRemaining = session => {\n  const now = new Date();\n  const sessionDate = session.session_date;\n  const [startHour, startMin] = session.start_time.split(':').map(Number);\n  const [endHour, endMin] = session.end_time.split(':').map(Number);\n  const startDateTime = new Date(sessionDate);\n  startDateTime.setHours(startHour, startMin, 0, 0);\n  const endDateTime = new Date(sessionDate);\n  endDateTime.setHours(endHour, endMin, 0, 0);\n  if (now < startDateTime) {\n    const diffMs = startDateTime - now;\n    const minutes = Math.floor(diffMs / 60000);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return {\n      type: 'start',\n      minutes,\n      formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\n    };\n  } else if (now < endDateTime) {\n    const diffMs = endDateTime - now;\n    const minutes = Math.floor(diffMs / 60000);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return {\n      type: 'end',\n      minutes,\n      formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\n    };\n  }\n  return {\n    type: 'ended',\n    minutes: 0,\n    formatted: 'Session ended'\n  };\n};","map":{"version":3,"names":["supabase","SESSION_STATUS","SCHEDULED","OPEN","CLOSED","ATTENDANCE_STATUS","PRESENT","LATE","ABSENT","LATE_WINDOW_MINUTES","calculateSessionStatus","session","now","Date","sessionDate","session_date","startHour","startMin","start_time","split","map","Number","endHour","endMin","end_time","startDateTime","setHours","endDateTime","canMarkAttendance","studentId","status","canMark","reason","data","classData","error","classError","from","select","eq","class_id","single","enrollment","enrollError","course_id","existingAttendance","attendanceError","id","isLateAttendance","lateThreshold","setMinutes","getMinutes","markAttendanceWithStatus","sessionId","sessionError","success","attendance","attendanceStatus","insert","student_id","session_id","marked_at","toISOString","code","message","console","autoMarkAbsentStudents","absentCount","enrollments","classes","presentStudents","presentError","presentStudentIds","Set","a","absentStudents","filter","e","has","length","insertError","checkOverlappingSessions","classId","date","startTime","endTime","excludeSessionId","query","neq","sessions","overlapping","existingStart","existingEnd","hasOverlap","overlappingSessions","createSessionWithValidation","delegateId","s","join","token","Math","random","toString","substring","expiresAt","expires_at","getStudentSessionsByStatus","courseIds","in","classIds","c","order","ascending","attendanceMap","Map","scheduled","open","closed","_session$classes","_session$classes$cour","_session$classes2","_session$classes2$cou","_session$classes3","isMarked","get","enrichedSession","courseCode","courses","course_code","courseTitle","course_title","className","class_name","toLocaleDateString","push","getDelegateSessionsByStatus","sessionIds","attendanceCounts","countError","countMap","forEach","set","_session$classes4","_session$classes4$cou","_session$classes5","_session$classes5$cou","_session$classes6","attendanceCount","processSessionClosure","result","log","getTimeRemaining","diffMs","minutes","floor","hours","mins","type","formatted"],"sources":["C:/Users/PFI/Desktop/ictuattennce_portal/ATTENDANCE/src/utils/sessionLifecycle.js"],"sourcesContent":["import { supabase } from '../supabase/supabase';\r\n\r\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\r\n\r\n// Session status constants\r\nexport const SESSION_STATUS = {\r\n    SCHEDULED: 'scheduled',\r\n    OPEN: 'open',\r\n    CLOSED: 'closed'\r\n};\r\n\r\n// Attendance status constants\r\nexport const ATTENDANCE_STATUS = {\r\n    PRESENT: 'present',\r\n    LATE: 'late',\r\n    ABSENT: 'absent'\r\n};\r\n\r\n// Late window in minutes (first 10 minutes after session start)\r\nexport const LATE_WINDOW_MINUTES = 10;\r\n\r\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\r\nexport const calculateSessionStatus = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    // Parse start and end times\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n    const [endHour, endMin] = session.end_time.split(':').map(Number);\r\n\r\n    // Create full datetime objects in local timezone\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const endDateTime = new Date(sessionDate);\r\n    endDateTime.setHours(endHour, endMin, 0, 0);\r\n\r\n    // Determine status based on local time\r\n    if (now < startDateTime) {\r\n        return SESSION_STATUS.SCHEDULED;\r\n    } else if (now >= startDateTime && now <= endDateTime) {\r\n        return SESSION_STATUS.OPEN;\r\n    } else {\r\n        return SESSION_STATUS.CLOSED;\r\n    }\r\n};\r\n\r\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\r\nexport const canMarkAttendance = async (session, studentId) => {\r\n    const status = calculateSessionStatus(session);\r\n\r\n    // Check if session is open\r\n    if (status === SESSION_STATUS.SCHEDULED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has not started yet',\r\n            status\r\n        };\r\n    }\r\n\r\n    if (status === SESSION_STATUS.CLOSED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has ended. Attendance is locked.',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student is enrolled in the course\r\n    const { data: classData, error: classError } = await supabase\r\n        .from('classes')\r\n        .select('course_id')\r\n        .eq('id', session.class_id)\r\n        .single();\r\n\r\n    if (classError || !classData) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Unable to verify enrollment',\r\n            status\r\n        };\r\n    }\r\n\r\n    const { data: enrollment, error: enrollError } = await supabase\r\n        .from('enrollments')\r\n        .select('id')\r\n        .eq('student_id', studentId)\r\n        .eq('course_id', classData.course_id)\r\n        .single();\r\n\r\n    if (enrollError || !enrollment) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You are not enrolled in this course',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student has already marked attendance\r\n    const { data: existingAttendance, error: attendanceError } = await supabase\r\n        .from('attendance')\r\n        .select('id')\r\n        .eq('session_id', session.id)\r\n        .eq('student_id', studentId)\r\n        .single();\r\n\r\n    if (existingAttendance) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You have already marked attendance for this session',\r\n            status\r\n        };\r\n    }\r\n\r\n    return {\r\n        canMark: true,\r\n        reason: 'Ready to mark attendance',\r\n        status\r\n    };\r\n};\r\n\r\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\r\nexport const isLateAttendance = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const lateThreshold = new Date(startDateTime);\r\n    lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\r\n\r\n    return now > lateThreshold;\r\n};\r\n\r\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\r\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\r\n    try {\r\n        // First get the session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, attendance: null, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if student can mark attendance\r\n        const { canMark, reason, status } = await canMarkAttendance(session, studentId);\r\n\r\n        if (!canMark) {\r\n            return { success: false, attendance: null, error: reason };\r\n        }\r\n\r\n        // Determine attendance status (present or late)\r\n        const attendanceStatus = isLateAttendance(session)\r\n            ? ATTENDANCE_STATUS.LATE\r\n            : ATTENDANCE_STATUS.PRESENT;\r\n\r\n        // Insert attendance record\r\n        const { data, error } = await supabase\r\n            .from('attendance')\r\n            .insert({\r\n                student_id: studentId,\r\n                session_id: sessionId,\r\n                status: attendanceStatus,\r\n                marked_at: new Date().toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) {\r\n            // Check for duplicate entry\r\n            if (error.code === '23505') {\r\n                return { success: false, attendance: null, error: 'Attendance already marked' };\r\n            }\r\n            throw error;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            attendance: data?.[0],\r\n            error: null,\r\n            status: attendanceStatus,\r\n            message: attendanceStatus === ATTENDANCE_STATUS.LATE\r\n                ? 'Attendance marked as LATE'\r\n                : 'Attendance marked successfully!'\r\n        };\r\n    } catch (error) {\r\n        console.error('Error marking attendance:', error);\r\n        return { success: false, attendance: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\r\nexport const autoMarkAbsentStudents = async (sessionId) => {\r\n    try {\r\n        // Get session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*, classes!inner(course_id)')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, absentCount: 0, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if session is closed\r\n        const status = calculateSessionStatus(session);\r\n        if (status !== SESSION_STATUS.CLOSED) {\r\n            return { success: false, absentCount: 0, error: 'Session is not closed yet' };\r\n        }\r\n\r\n        // Get all enrolled students for this course\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('student_id')\r\n            .eq('course_id', session.classes.course_id);\r\n\r\n        if (enrollError) {\r\n            throw enrollError;\r\n        }\r\n\r\n        // Get students who already marked attendance\r\n        const { data: presentStudents, error: presentError } = await supabase\r\n            .from('attendance')\r\n            .select('student_id')\r\n            .eq('session_id', sessionId);\r\n\r\n        if (presentError) {\r\n            throw presentError;\r\n        }\r\n\r\n        const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\r\n\r\n        // Find students who didn't mark attendance\r\n        const absentStudents = (enrollments || [])\r\n            .filter(e => !presentStudentIds.has(e.student_id))\r\n            .map(e => ({\r\n                student_id: e.student_id,\r\n                session_id: sessionId,\r\n                status: ATTENDANCE_STATUS.ABSENT,\r\n                marked_at: new Date().toISOString()\r\n            }));\r\n\r\n        if (absentStudents.length === 0) {\r\n            return { success: true, absentCount: 0, error: null };\r\n        }\r\n\r\n        // Insert absent records\r\n        const { error: insertError } = await supabase\r\n            .from('attendance')\r\n            .insert(absentStudents);\r\n\r\n        if (insertError) {\r\n            throw insertError;\r\n        }\r\n\r\n        return { success: true, absentCount: absentStudents.length, error: null };\r\n    } catch (error) {\r\n        console.error('Error auto-marking absent students:', error);\r\n        return { success: false, absentCount: 0, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\r\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\r\n    try {\r\n        let query = supabase\r\n            .from('sessions')\r\n            .select('id, start_time, end_time')\r\n            .eq('class_id', classId)\r\n            .eq('session_date', date);\r\n\r\n        if (excludeSessionId) {\r\n            query = query.neq('id', excludeSessionId);\r\n        }\r\n\r\n        const { data: sessions, error } = await query;\r\n\r\n        if (error) {\r\n            throw error;\r\n        }\r\n\r\n        // Check for time overlaps\r\n        const overlapping = (sessions || []).filter(session => {\r\n            const existingStart = session.start_time;\r\n            const existingEnd = session.end_time;\r\n\r\n            // Check if times overlap\r\n            return (startTime < existingEnd && endTime > existingStart);\r\n        });\r\n\r\n        return {\r\n            hasOverlap: overlapping.length > 0,\r\n            overlappingSessions: overlapping\r\n        };\r\n    } catch (error) {\r\n        console.error('Error checking overlapping sessions:', error);\r\n        return { hasOverlap: false, overlappingSessions: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\r\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\r\n    try {\r\n        // Check for overlapping sessions\r\n        const { hasOverlap, overlappingSessions } = await checkOverlappingSessions(\r\n            classId, sessionDate, startTime, endTime\r\n        );\r\n\r\n        if (hasOverlap) {\r\n            return {\r\n                session: null,\r\n                error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\r\n            };\r\n        }\r\n\r\n        // Generate a unique token\r\n        const token = Math.random().toString(36).substring(2, 15) +\r\n            Math.random().toString(36).substring(2, 15);\r\n\r\n        // Calculate expires_at (same as end time for automatic closure) in Cameroon timezone\r\n        const expiresAt = new Date(sessionDate + 'T' + endTime + ':00+01:00');\r\n\r\n        const { data, error } = await supabase\r\n            .from('sessions')\r\n            .insert({\r\n                class_id: classId,\r\n                session_date: sessionDate,\r\n                start_time: startTime,\r\n                end_time: endTime,\r\n                token,\r\n                expires_at: expiresAt.toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) throw error;\r\n\r\n        return { session: data?.[0], error: null };\r\n    } catch (error) {\r\n        console.error('Error creating session:', error);\r\n        return { session: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getStudentSessionsByStatus = async (studentId) => {\r\n    try {\r\n        // Get student's enrolled courses\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('course_id')\r\n            .eq('student_id', studentId);\r\n\r\n        if (enrollError) throw enrollError;\r\n\r\n        const courseIds = (enrollments || []).map(e => e.course_id);\r\n\r\n        // Get classes for these courses\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .in('course_id', courseIds);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get student's attendance records\r\n        const { data: attendance, error: attendanceError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id, status')\r\n            .eq('student_id', studentId);\r\n\r\n        if (attendanceError) throw attendanceError;\r\n\r\n        const attendanceMap = new Map(\r\n            (attendance || []).map(a => [a.session_id, a.status])\r\n        );\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n            const isMarked = attendanceMap.has(session.id);\r\n            const attendanceStatus = attendanceMap.get(session.id);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                isMarked,\r\n                attendanceStatus,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching student sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getDelegateSessionsByStatus = async (delegateId) => {\r\n    try {\r\n        // Get delegate's classes\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .eq('delegate_id', delegateId);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get attendance counts for each session\r\n        const sessionIds = (sessions || []).map(s => s.id);\r\n        const { data: attendanceCounts, error: countError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id')\r\n            .in('session_id', sessionIds);\r\n\r\n        // Count attendance per session\r\n        const countMap = new Map();\r\n        (attendanceCounts || []).forEach(a => {\r\n            countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\r\n        });\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                attendanceCount: countMap.get(session.id) || 0,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching delegate sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\r\nexport const processSessionClosure = async (sessionId) => {\r\n    try {\r\n        // Auto-mark absent students\r\n        const result = await autoMarkAbsentStudents(sessionId);\r\n\r\n        if (!result.success) {\r\n            console.error('Failed to auto-mark absent students:', result.error);\r\n        } else {\r\n            console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\r\n        }\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error processing session closure:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\r\nexport const getTimeRemaining = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n    const [endHour, endMin] = session.end_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const endDateTime = new Date(sessionDate);\r\n    endDateTime.setHours(endHour, endMin, 0, 0);\r\n\r\n    if (now < startDateTime) {\r\n        const diffMs = startDateTime - now;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'start',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\r\n        };\r\n    } else if (now < endDateTime) {\r\n        const diffMs = endDateTime - now;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'end',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\r\n        };\r\n    }\r\n\r\n    return {\r\n        type: 'ended',\r\n        minutes: 0,\r\n        formatted: 'Session ended'\r\n    };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}