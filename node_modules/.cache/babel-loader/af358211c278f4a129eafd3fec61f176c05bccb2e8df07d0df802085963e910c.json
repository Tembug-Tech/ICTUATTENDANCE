{"ast":null,"code":"import{supabase}from'../supabase/supabase';/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */// Session status constants\nexport const SESSION_STATUS={SCHEDULED:'scheduled',OPEN:'open',CLOSED:'closed'};// Attendance status constants\nexport const ATTENDANCE_STATUS={PRESENT:'present',LATE:'late',ABSENT:'absent'};// Late window in minutes (first 10 minutes after session start)\nexport const LATE_WINDOW_MINUTES=10;/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */export const calculateSessionStatus=session=>{const now=new Date();const sessionDate=session.session_date;// Parse start and end times\nconst[startHour,startMin]=session.start_time.split(':').map(Number);const[endHour,endMin]=session.end_time.split(':').map(Number);// Create full datetime objects\nconst startDateTime=new Date(sessionDate);startDateTime.setHours(startHour,startMin,0,0);const endDateTime=new Date(sessionDate);endDateTime.setHours(endHour,endMin,0,0);// Determine status\nif(now<startDateTime){return SESSION_STATUS.SCHEDULED;}else if(now>=startDateTime&&now<=endDateTime){return SESSION_STATUS.OPEN;}else{return SESSION_STATUS.CLOSED;}};/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */export const canMarkAttendance=async(session,studentId)=>{const status=calculateSessionStatus(session);// Check if session is open\nif(status===SESSION_STATUS.SCHEDULED){return{canMark:false,reason:'Session has not started yet',status};}if(status===SESSION_STATUS.CLOSED){return{canMark:false,reason:'Session has ended. Attendance is locked.',status};}// Check if student is enrolled in the course\nconst{data:classData,error:classError}=await supabase.from('classes').select('course_id').eq('id',session.class_id).single();if(classError||!classData){return{canMark:false,reason:'Unable to verify enrollment',status};}const{data:enrollment,error:enrollError}=await supabase.from('enrollments').select('id').eq('student_id',studentId).eq('course_id',classData.course_id).single();if(enrollError||!enrollment){return{canMark:false,reason:'You are not enrolled in this course',status};}// Check if student has already marked attendance\nconst{data:existingAttendance,error:attendanceError}=await supabase.from('attendance').select('id').eq('session_id',session.id).eq('student_id',studentId).single();if(existingAttendance){return{canMark:false,reason:'You have already marked attendance for this session',status};}return{canMark:true,reason:'Ready to mark attendance',status};};/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */export const isLateAttendance=session=>{const now=new Date();const sessionDate=session.session_date;const[startHour,startMin]=session.start_time.split(':').map(Number);const startDateTime=new Date(sessionDate);startDateTime.setHours(startHour,startMin,0,0);const lateThreshold=new Date(startDateTime);lateThreshold.setMinutes(lateThreshold.getMinutes()+LATE_WINDOW_MINUTES);return now>lateThreshold;};/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */export const markAttendanceWithStatus=async(studentId,sessionId)=>{try{// First get the session details\nconst{data:session,error:sessionError}=await supabase.from('sessions').select('*').eq('id',sessionId).single();if(sessionError||!session){return{success:false,attendance:null,error:'Session not found'};}// Check if student can mark attendance\nconst{canMark,reason,status}=await canMarkAttendance(session,studentId);if(!canMark){return{success:false,attendance:null,error:reason};}// Determine attendance status (present or late)\nconst attendanceStatus=isLateAttendance(session)?ATTENDANCE_STATUS.LATE:ATTENDANCE_STATUS.PRESENT;// Insert attendance record\nconst{data,error}=await supabase.from('attendance').insert({student_id:studentId,session_id:sessionId,status:attendanceStatus,marked_at:new Date().toISOString()}).select();if(error){// Check for duplicate entry\nif(error.code==='23505'){return{success:false,attendance:null,error:'Attendance already marked'};}throw error;}return{success:true,attendance:data===null||data===void 0?void 0:data[0],error:null,status:attendanceStatus,message:attendanceStatus===ATTENDANCE_STATUS.LATE?'Attendance marked as LATE':'Attendance marked successfully!'};}catch(error){console.error('Error marking attendance:',error);return{success:false,attendance:null,error:error.message};}};/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */export const autoMarkAbsentStudents=async sessionId=>{try{// Get session details\nconst{data:session,error:sessionError}=await supabase.from('sessions').select('*, classes!inner(course_id)').eq('id',sessionId).single();if(sessionError||!session){return{success:false,absentCount:0,error:'Session not found'};}// Check if session is closed\nconst status=calculateSessionStatus(session);if(status!==SESSION_STATUS.CLOSED){return{success:false,absentCount:0,error:'Session is not closed yet'};}// Get all enrolled students for this course\nconst{data:enrollments,error:enrollError}=await supabase.from('enrollments').select('student_id').eq('course_id',session.classes.course_id);if(enrollError){throw enrollError;}// Get students who already marked attendance\nconst{data:presentStudents,error:presentError}=await supabase.from('attendance').select('student_id').eq('session_id',sessionId);if(presentError){throw presentError;}const presentStudentIds=new Set((presentStudents||[]).map(a=>a.student_id));// Find students who didn't mark attendance\nconst absentStudents=(enrollments||[]).filter(e=>!presentStudentIds.has(e.student_id)).map(e=>({student_id:e.student_id,session_id:sessionId,status:ATTENDANCE_STATUS.ABSENT,marked_at:new Date().toISOString()}));if(absentStudents.length===0){return{success:true,absentCount:0,error:null};}// Insert absent records\nconst{error:insertError}=await supabase.from('attendance').insert(absentStudents);if(insertError){throw insertError;}return{success:true,absentCount:absentStudents.length,error:null};}catch(error){console.error('Error auto-marking absent students:',error);return{success:false,absentCount:0,error:error.message};}};/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */export const checkOverlappingSessions=async function(classId,date,startTime,endTime){let excludeSessionId=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;try{let query=supabase.from('sessions').select('id, start_time, end_time').eq('class_id',classId).eq('session_date',date);if(excludeSessionId){query=query.neq('id',excludeSessionId);}const{data:sessions,error}=await query;if(error){throw error;}// Check for time overlaps\nconst overlapping=(sessions||[]).filter(session=>{const existingStart=session.start_time;const existingEnd=session.end_time;// Check if times overlap\nreturn startTime<existingEnd&&endTime>existingStart;});return{hasOverlap:overlapping.length>0,overlappingSessions:overlapping};}catch(error){console.error('Error checking overlapping sessions:',error);return{hasOverlap:false,overlappingSessions:[],error:error.message};}};/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */export const createSessionWithValidation=async(delegateId,classId,sessionDate,startTime,endTime)=>{try{// Check for overlapping sessions\nconst{hasOverlap,overlappingSessions}=await checkOverlappingSessions(classId,sessionDate,startTime,endTime);if(hasOverlap){return{session:null,error:\"Session overlaps with existing session(s) at \".concat(overlappingSessions.map(s=>s.start_time).join(', '))};}// Generate a unique token\nconst token=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);// Calculate expires_at (same as end time for automatic closure)\nconst[endHour,endMin]=endTime.split(':');const expiresAt=new Date(sessionDate);expiresAt.setHours(parseInt(endHour),parseInt(endMin),0);const{data,error}=await supabase.from('sessions').insert({class_id:classId,session_date:sessionDate,start_time:startTime,end_time:endTime,token,expires_at:expiresAt.toISOString(),status:SESSION_STATUS.SCHEDULED}).select();if(error)throw error;return{session:data===null||data===void 0?void 0:data[0],error:null};}catch(error){console.error('Error creating session:',error);return{session:null,error:error.message};}};/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */export const getStudentSessionsByStatus=async studentId=>{try{// Get student's enrolled courses\nconst{data:enrollments,error:enrollError}=await supabase.from('enrollments').select('course_id').eq('student_id',studentId);if(enrollError)throw enrollError;const courseIds=(enrollments||[]).map(e=>e.course_id);// Get classes for these courses\nconst{data:classes,error:classError}=await supabase.from('classes').select('id').in('course_id',courseIds);if(classError)throw classError;const classIds=(classes||[]).map(c=>c.id);// Get all sessions for these classes\nconst{data:sessions,error:sessionError}=await supabase.from('sessions').select(\"\\n        id,\\n        session_date,\\n        start_time,\\n        end_time,\\n        token,\\n        expires_at,\\n        classes!inner (\\n          id,\\n          class_name,\\n          courses!inner (course_code, course_title)\\n        )\\n      \").in('class_id',classIds).order('session_date',{ascending:false});if(sessionError)throw sessionError;// Get student's attendance records\nconst{data:attendance,error:attendanceError}=await supabase.from('attendance').select('session_id, status').eq('student_id',studentId);if(attendanceError)throw attendanceError;const attendanceMap=new Map((attendance||[]).map(a=>[a.session_id,a.status]));// Categorize sessions by status\nconst scheduled=[];const open=[];const closed=[];for(const session of sessions||[]){var _session$classes,_session$classes$cour,_session$classes2,_session$classes2$cou,_session$classes3;const status=calculateSessionStatus(session);const isMarked=attendanceMap.has(session.id);const attendanceStatus=attendanceMap.get(session.id);const enrichedSession={id:session.id,courseCode:(_session$classes=session.classes)===null||_session$classes===void 0?void 0:(_session$classes$cour=_session$classes.courses)===null||_session$classes$cour===void 0?void 0:_session$classes$cour.course_code,courseTitle:(_session$classes2=session.classes)===null||_session$classes2===void 0?void 0:(_session$classes2$cou=_session$classes2.courses)===null||_session$classes2$cou===void 0?void 0:_session$classes2$cou.course_title,className:(_session$classes3=session.classes)===null||_session$classes3===void 0?void 0:_session$classes3.class_name,date:new Date(session.session_date).toLocaleDateString(),startTime:session.start_time,endTime:session.end_time,status,isMarked,attendanceStatus,token:session.token};switch(status){case SESSION_STATUS.SCHEDULED:scheduled.push(enrichedSession);break;case SESSION_STATUS.OPEN:open.push(enrichedSession);break;case SESSION_STATUS.CLOSED:closed.push(enrichedSession);break;}}return{scheduled,open,closed,error:null};}catch(error){console.error('Error fetching student sessions:',error);return{scheduled:[],open:[],closed:[],error:error.message};}};/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */export const getDelegateSessionsByStatus=async delegateId=>{try{// Get delegate's classes\nconst{data:classes,error:classError}=await supabase.from('classes').select('id').eq('delegate_id',delegateId);if(classError)throw classError;const classIds=(classes||[]).map(c=>c.id);// Get all sessions for these classes\nconst{data:sessions,error:sessionError}=await supabase.from('sessions').select(\"\\n        id,\\n        session_date,\\n        start_time,\\n        end_time,\\n        token,\\n        expires_at,\\n        classes!inner (\\n          id,\\n          class_name,\\n          courses!inner (course_code, course_title)\\n        )\\n      \").in('class_id',classIds).order('session_date',{ascending:false});if(sessionError)throw sessionError;// Get attendance counts for each session\nconst sessionIds=(sessions||[]).map(s=>s.id);const{data:attendanceCounts,error:countError}=await supabase.from('attendance').select('session_id').in('session_id',sessionIds);// Count attendance per session\nconst countMap=new Map();(attendanceCounts||[]).forEach(a=>{countMap.set(a.session_id,(countMap.get(a.session_id)||0)+1);});// Categorize sessions by status\nconst scheduled=[];const open=[];const closed=[];for(const session of sessions||[]){var _session$classes4,_session$classes4$cou,_session$classes5,_session$classes5$cou,_session$classes6;const status=calculateSessionStatus(session);const enrichedSession={id:session.id,courseCode:(_session$classes4=session.classes)===null||_session$classes4===void 0?void 0:(_session$classes4$cou=_session$classes4.courses)===null||_session$classes4$cou===void 0?void 0:_session$classes4$cou.course_code,courseTitle:(_session$classes5=session.classes)===null||_session$classes5===void 0?void 0:(_session$classes5$cou=_session$classes5.courses)===null||_session$classes5$cou===void 0?void 0:_session$classes5$cou.course_title,className:(_session$classes6=session.classes)===null||_session$classes6===void 0?void 0:_session$classes6.class_name,date:new Date(session.session_date).toLocaleDateString(),startTime:session.start_time,endTime:session.end_time,status,attendanceCount:countMap.get(session.id)||0,token:session.token};switch(status){case SESSION_STATUS.SCHEDULED:scheduled.push(enrichedSession);break;case SESSION_STATUS.OPEN:open.push(enrichedSession);break;case SESSION_STATUS.CLOSED:closed.push(enrichedSession);break;}}return{scheduled,open,closed,error:null};}catch(error){console.error('Error fetching delegate sessions:',error);return{scheduled:[],open:[],closed:[],error:error.message};}};/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */export const processSessionClosure=async sessionId=>{try{// Auto-mark absent students\nconst result=await autoMarkAbsentStudents(sessionId);if(!result.success){console.error('Failed to auto-mark absent students:',result.error);}else{console.log(\"Session \".concat(sessionId,\" closed. \").concat(result.absentCount,\" students marked absent.\"));}return result;}catch(error){console.error('Error processing session closure:',error);return{success:false,error:error.message};}};/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */export const getTimeRemaining=session=>{const now=new Date();const sessionDate=session.session_date;const[startHour,startMin]=session.start_time.split(':').map(Number);const[endHour,endMin]=session.end_time.split(':').map(Number);const startDateTime=new Date(sessionDate);startDateTime.setHours(startHour,startMin,0,0);const endDateTime=new Date(sessionDate);endDateTime.setHours(endHour,endMin,0,0);if(now<startDateTime){const diffMs=startDateTime-now;const minutes=Math.floor(diffMs/60000);const hours=Math.floor(minutes/60);const mins=minutes%60;return{type:'start',minutes,formatted:hours>0?\"\".concat(hours,\"h \").concat(mins,\"m until start\"):\"\".concat(mins,\"m until start\")};}else if(now<endDateTime){const diffMs=endDateTime-now;const minutes=Math.floor(diffMs/60000);const hours=Math.floor(minutes/60);const mins=minutes%60;return{type:'end',minutes,formatted:hours>0?\"\".concat(hours,\"h \").concat(mins,\"m remaining\"):\"\".concat(mins,\"m remaining\")};}return{type:'ended',minutes:0,formatted:'Session ended'};};","map":{"version":3,"names":["supabase","SESSION_STATUS","SCHEDULED","OPEN","CLOSED","ATTENDANCE_STATUS","PRESENT","LATE","ABSENT","LATE_WINDOW_MINUTES","calculateSessionStatus","session","now","Date","sessionDate","session_date","startHour","startMin","start_time","split","map","Number","endHour","endMin","end_time","startDateTime","setHours","endDateTime","canMarkAttendance","studentId","status","canMark","reason","data","classData","error","classError","from","select","eq","class_id","single","enrollment","enrollError","course_id","existingAttendance","attendanceError","id","isLateAttendance","lateThreshold","setMinutes","getMinutes","markAttendanceWithStatus","sessionId","sessionError","success","attendance","attendanceStatus","insert","student_id","session_id","marked_at","toISOString","code","message","console","autoMarkAbsentStudents","absentCount","enrollments","classes","presentStudents","presentError","presentStudentIds","Set","a","absentStudents","filter","e","has","length","insertError","checkOverlappingSessions","classId","date","startTime","endTime","excludeSessionId","arguments","undefined","query","neq","sessions","overlapping","existingStart","existingEnd","hasOverlap","overlappingSessions","createSessionWithValidation","delegateId","concat","s","join","token","Math","random","toString","substring","expiresAt","parseInt","expires_at","getStudentSessionsByStatus","courseIds","in","classIds","c","order","ascending","attendanceMap","Map","scheduled","open","closed","_session$classes","_session$classes$cour","_session$classes2","_session$classes2$cou","_session$classes3","isMarked","get","enrichedSession","courseCode","courses","course_code","courseTitle","course_title","className","class_name","toLocaleDateString","push","getDelegateSessionsByStatus","sessionIds","attendanceCounts","countError","countMap","forEach","set","_session$classes4","_session$classes4$cou","_session$classes5","_session$classes5$cou","_session$classes6","attendanceCount","processSessionClosure","result","log","getTimeRemaining","diffMs","minutes","floor","hours","mins","type","formatted"],"sources":["c:/Users/PFI/Desktop/ictuattennce_portal/ATTENDANCE/src/utils/sessionLifecycle.js"],"sourcesContent":["import { supabase } from '../supabase/supabase';\r\n\r\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\r\n\r\n// Session status constants\r\nexport const SESSION_STATUS = {\r\n    SCHEDULED: 'scheduled',\r\n    OPEN: 'open',\r\n    CLOSED: 'closed'\r\n};\r\n\r\n// Attendance status constants\r\nexport const ATTENDANCE_STATUS = {\r\n    PRESENT: 'present',\r\n    LATE: 'late',\r\n    ABSENT: 'absent'\r\n};\r\n\r\n// Late window in minutes (first 10 minutes after session start)\r\nexport const LATE_WINDOW_MINUTES = 10;\r\n\r\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\r\nexport const calculateSessionStatus = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    // Parse start and end times\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n    const [endHour, endMin] = session.end_time.split(':').map(Number);\r\n\r\n    // Create full datetime objects\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const endDateTime = new Date(sessionDate);\r\n    endDateTime.setHours(endHour, endMin, 0, 0);\r\n\r\n    // Determine status\r\n    if (now < startDateTime) {\r\n        return SESSION_STATUS.SCHEDULED;\r\n    } else if (now >= startDateTime && now <= endDateTime) {\r\n        return SESSION_STATUS.OPEN;\r\n    } else {\r\n        return SESSION_STATUS.CLOSED;\r\n    }\r\n};\r\n\r\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\r\nexport const canMarkAttendance = async (session, studentId) => {\r\n    const status = calculateSessionStatus(session);\r\n\r\n    // Check if session is open\r\n    if (status === SESSION_STATUS.SCHEDULED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has not started yet',\r\n            status\r\n        };\r\n    }\r\n\r\n    if (status === SESSION_STATUS.CLOSED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has ended. Attendance is locked.',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student is enrolled in the course\r\n    const { data: classData, error: classError } = await supabase\r\n        .from('classes')\r\n        .select('course_id')\r\n        .eq('id', session.class_id)\r\n        .single();\r\n\r\n    if (classError || !classData) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Unable to verify enrollment',\r\n            status\r\n        };\r\n    }\r\n\r\n    const { data: enrollment, error: enrollError } = await supabase\r\n        .from('enrollments')\r\n        .select('id')\r\n        .eq('student_id', studentId)\r\n        .eq('course_id', classData.course_id)\r\n        .single();\r\n\r\n    if (enrollError || !enrollment) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You are not enrolled in this course',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student has already marked attendance\r\n    const { data: existingAttendance, error: attendanceError } = await supabase\r\n        .from('attendance')\r\n        .select('id')\r\n        .eq('session_id', session.id)\r\n        .eq('student_id', studentId)\r\n        .single();\r\n\r\n    if (existingAttendance) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You have already marked attendance for this session',\r\n            status\r\n        };\r\n    }\r\n\r\n    return {\r\n        canMark: true,\r\n        reason: 'Ready to mark attendance',\r\n        status\r\n    };\r\n};\r\n\r\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\r\nexport const isLateAttendance = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const lateThreshold = new Date(startDateTime);\r\n    lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\r\n\r\n    return now > lateThreshold;\r\n};\r\n\r\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\r\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\r\n    try {\r\n        // First get the session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, attendance: null, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if student can mark attendance\r\n        const { canMark, reason, status } = await canMarkAttendance(session, studentId);\r\n\r\n        if (!canMark) {\r\n            return { success: false, attendance: null, error: reason };\r\n        }\r\n\r\n        // Determine attendance status (present or late)\r\n        const attendanceStatus = isLateAttendance(session)\r\n            ? ATTENDANCE_STATUS.LATE\r\n            : ATTENDANCE_STATUS.PRESENT;\r\n\r\n        // Insert attendance record\r\n        const { data, error } = await supabase\r\n            .from('attendance')\r\n            .insert({\r\n                student_id: studentId,\r\n                session_id: sessionId,\r\n                status: attendanceStatus,\r\n                marked_at: new Date().toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) {\r\n            // Check for duplicate entry\r\n            if (error.code === '23505') {\r\n                return { success: false, attendance: null, error: 'Attendance already marked' };\r\n            }\r\n            throw error;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            attendance: data?.[0],\r\n            error: null,\r\n            status: attendanceStatus,\r\n            message: attendanceStatus === ATTENDANCE_STATUS.LATE\r\n                ? 'Attendance marked as LATE'\r\n                : 'Attendance marked successfully!'\r\n        };\r\n    } catch (error) {\r\n        console.error('Error marking attendance:', error);\r\n        return { success: false, attendance: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\r\nexport const autoMarkAbsentStudents = async (sessionId) => {\r\n    try {\r\n        // Get session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*, classes!inner(course_id)')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, absentCount: 0, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if session is closed\r\n        const status = calculateSessionStatus(session);\r\n        if (status !== SESSION_STATUS.CLOSED) {\r\n            return { success: false, absentCount: 0, error: 'Session is not closed yet' };\r\n        }\r\n\r\n        // Get all enrolled students for this course\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('student_id')\r\n            .eq('course_id', session.classes.course_id);\r\n\r\n        if (enrollError) {\r\n            throw enrollError;\r\n        }\r\n\r\n        // Get students who already marked attendance\r\n        const { data: presentStudents, error: presentError } = await supabase\r\n            .from('attendance')\r\n            .select('student_id')\r\n            .eq('session_id', sessionId);\r\n\r\n        if (presentError) {\r\n            throw presentError;\r\n        }\r\n\r\n        const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\r\n\r\n        // Find students who didn't mark attendance\r\n        const absentStudents = (enrollments || [])\r\n            .filter(e => !presentStudentIds.has(e.student_id))\r\n            .map(e => ({\r\n                student_id: e.student_id,\r\n                session_id: sessionId,\r\n                status: ATTENDANCE_STATUS.ABSENT,\r\n                marked_at: new Date().toISOString()\r\n            }));\r\n\r\n        if (absentStudents.length === 0) {\r\n            return { success: true, absentCount: 0, error: null };\r\n        }\r\n\r\n        // Insert absent records\r\n        const { error: insertError } = await supabase\r\n            .from('attendance')\r\n            .insert(absentStudents);\r\n\r\n        if (insertError) {\r\n            throw insertError;\r\n        }\r\n\r\n        return { success: true, absentCount: absentStudents.length, error: null };\r\n    } catch (error) {\r\n        console.error('Error auto-marking absent students:', error);\r\n        return { success: false, absentCount: 0, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\r\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\r\n    try {\r\n        let query = supabase\r\n            .from('sessions')\r\n            .select('id, start_time, end_time')\r\n            .eq('class_id', classId)\r\n            .eq('session_date', date);\r\n\r\n        if (excludeSessionId) {\r\n            query = query.neq('id', excludeSessionId);\r\n        }\r\n\r\n        const { data: sessions, error } = await query;\r\n\r\n        if (error) {\r\n            throw error;\r\n        }\r\n\r\n        // Check for time overlaps\r\n        const overlapping = (sessions || []).filter(session => {\r\n            const existingStart = session.start_time;\r\n            const existingEnd = session.end_time;\r\n\r\n            // Check if times overlap\r\n            return (startTime < existingEnd && endTime > existingStart);\r\n        });\r\n\r\n        return {\r\n            hasOverlap: overlapping.length > 0,\r\n            overlappingSessions: overlapping\r\n        };\r\n    } catch (error) {\r\n        console.error('Error checking overlapping sessions:', error);\r\n        return { hasOverlap: false, overlappingSessions: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\r\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\r\n    try {\r\n        // Check for overlapping sessions\r\n        const { hasOverlap, overlappingSessions } = await checkOverlappingSessions(\r\n            classId, sessionDate, startTime, endTime\r\n        );\r\n\r\n        if (hasOverlap) {\r\n            return {\r\n                session: null,\r\n                error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\r\n            };\r\n        }\r\n\r\n        // Generate a unique token\r\n        const token = Math.random().toString(36).substring(2, 15) +\r\n            Math.random().toString(36).substring(2, 15);\r\n\r\n        // Calculate expires_at (same as end time for automatic closure)\r\n        const [endHour, endMin] = endTime.split(':');\r\n        const expiresAt = new Date(sessionDate);\r\n        expiresAt.setHours(parseInt(endHour), parseInt(endMin), 0);\r\n\r\n        const { data, error } = await supabase\r\n            .from('sessions')\r\n            .insert({\r\n                class_id: classId,\r\n                session_date: sessionDate,\r\n                start_time: startTime,\r\n                end_time: endTime,\r\n                token,\r\n                expires_at: expiresAt.toISOString(),\r\n                status: SESSION_STATUS.SCHEDULED\r\n            })\r\n            .select();\r\n\r\n        if (error) throw error;\r\n\r\n        return { session: data?.[0], error: null };\r\n    } catch (error) {\r\n        console.error('Error creating session:', error);\r\n        return { session: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getStudentSessionsByStatus = async (studentId) => {\r\n    try {\r\n        // Get student's enrolled courses\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('course_id')\r\n            .eq('student_id', studentId);\r\n\r\n        if (enrollError) throw enrollError;\r\n\r\n        const courseIds = (enrollments || []).map(e => e.course_id);\r\n\r\n        // Get classes for these courses\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .in('course_id', courseIds);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get student's attendance records\r\n        const { data: attendance, error: attendanceError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id, status')\r\n            .eq('student_id', studentId);\r\n\r\n        if (attendanceError) throw attendanceError;\r\n\r\n        const attendanceMap = new Map(\r\n            (attendance || []).map(a => [a.session_id, a.status])\r\n        );\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n            const isMarked = attendanceMap.has(session.id);\r\n            const attendanceStatus = attendanceMap.get(session.id);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                isMarked,\r\n                attendanceStatus,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching student sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getDelegateSessionsByStatus = async (delegateId) => {\r\n    try {\r\n        // Get delegate's classes\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .eq('delegate_id', delegateId);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get attendance counts for each session\r\n        const sessionIds = (sessions || []).map(s => s.id);\r\n        const { data: attendanceCounts, error: countError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id')\r\n            .in('session_id', sessionIds);\r\n\r\n        // Count attendance per session\r\n        const countMap = new Map();\r\n        (attendanceCounts || []).forEach(a => {\r\n            countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\r\n        });\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                attendanceCount: countMap.get(session.id) || 0,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching delegate sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\r\nexport const processSessionClosure = async (sessionId) => {\r\n    try {\r\n        // Auto-mark absent students\r\n        const result = await autoMarkAbsentStudents(sessionId);\r\n\r\n        if (!result.success) {\r\n            console.error('Failed to auto-mark absent students:', result.error);\r\n        } else {\r\n            console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\r\n        }\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error processing session closure:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\r\nexport const getTimeRemaining = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n    const [endHour, endMin] = session.end_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const endDateTime = new Date(sessionDate);\r\n    endDateTime.setHours(endHour, endMin, 0, 0);\r\n\r\n    if (now < startDateTime) {\r\n        const diffMs = startDateTime - now;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'start',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\r\n        };\r\n    } else if (now < endDateTime) {\r\n        const diffMs = endDateTime - now;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'end',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\r\n        };\r\n    }\r\n\r\n    return {\r\n        type: 'ended',\r\n        minutes: 0,\r\n        formatted: 'Session ended'\r\n    };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}