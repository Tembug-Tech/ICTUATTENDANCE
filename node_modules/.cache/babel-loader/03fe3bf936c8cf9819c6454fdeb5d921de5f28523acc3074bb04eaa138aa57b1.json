{"ast":null,"code":"import{supabase}from'../supabase/supabase';/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */// Session status constants\nexport const SESSION_STATUS={SCHEDULED:'scheduled',OPEN:'open',CLOSED:'closed'};// Attendance status constants\nexport const ATTENDANCE_STATUS={PRESENT:'present',LATE:'late',ABSENT:'absent'};// Late window in minutes (first 10 minutes after session start)\nexport const LATE_WINDOW_MINUTES=10;/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */// Helper function to convert Cameroon time to UTC\nconst cameroonToUTC=(date,hour,min)=>{const cameroonTime=new Date(date);cameroonTime.setHours(hour,min,0,0);// Cameroon is UTC+1, so subtract 1 hour to get UTC\nreturn new Date(cameroonTime.getTime()-1*60*60*1000);};// Helper function to convert UTC to Cameroon time\nconst utcToCameroon=utcDate=>{// Add 1 hour to UTC to get Cameroon time\nreturn new Date(utcDate.getTime()+1*60*60*1000);};export const calculateSessionStatus=session=>{const now=new Date();// Handle different property names (database vs transformed)\nconst sessionDate=session.session_date||session.date;const startTime=session.start_time||session.startTime;const endTime=session.end_time||session.endTime;// Parse start and end times as Cameroon time, then convert to UTC for comparison\nconst[startHour,startMin]=startTime.split(':').map(Number);const[endHour,endMin]=endTime.split(':').map(Number);const startDateTimeUTC=cameroonToUTC(sessionDate,startHour,startMin);const endDateTimeUTC=cameroonToUTC(sessionDate,endHour,endMin);// Convert current time to UTC for comparison\nconst nowUTC=new Date(now.getTime()-now.getTimezoneOffset()*60*1000);// Determine status\nif(nowUTC<startDateTimeUTC){return SESSION_STATUS.SCHEDULED;}else if(nowUTC>=startDateTimeUTC&&nowUTC<=endDateTimeUTC){return SESSION_STATUS.OPEN;}else{return SESSION_STATUS.CLOSED;}};/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */export const canMarkAttendance=async(session,studentId)=>{const status=calculateSessionStatus(session);// Check if session is open\nif(status===SESSION_STATUS.SCHEDULED){return{canMark:false,reason:'Session has not started yet',status};}if(status===SESSION_STATUS.CLOSED){return{canMark:false,reason:'Session has ended. Attendance is locked.',status};}// Check if student is enrolled in the course\nconst{data:classData,error:classError}=await supabase.from('classes').select('course_id').eq('id',session.class_id).single();if(classError||!classData){return{canMark:false,reason:'Unable to verify enrollment',status};}const{data:enrollment,error:enrollError}=await supabase.from('enrollments').select('id').eq('student_id',studentId).eq('course_id',classData.course_id).single();if(enrollError||!enrollment){return{canMark:false,reason:'You are not enrolled in this course',status};}// Check if student has already marked attendance\nconst{data:existingAttendance,error:attendanceError}=await supabase.from('attendance').select('id').eq('session_id',session.id).eq('student_id',studentId).single();if(existingAttendance){return{canMark:false,reason:'You have already marked attendance for this session',status};}return{canMark:true,reason:'Ready to mark attendance',status};};/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */export const isLateAttendance=session=>{const now=new Date();const sessionDate=session.session_date;const[startHour,startMin]=session.start_time.split(':').map(Number);const startDateTime=new Date(sessionDate);startDateTime.setHours(startHour,startMin,0,0);const lateThreshold=new Date(startDateTime);lateThreshold.setMinutes(lateThreshold.getMinutes()+LATE_WINDOW_MINUTES);return now>lateThreshold;};/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */export const markAttendanceWithStatus=async(studentId,sessionId)=>{try{// First get the session details\nconst{data:session,error:sessionError}=await supabase.from('sessions').select('*').eq('id',sessionId).single();if(sessionError||!session){return{success:false,attendance:null,error:'Session not found'};}// Check if student can mark attendance\nconst{canMark,reason,status}=await canMarkAttendance(session,studentId);if(!canMark){return{success:false,attendance:null,error:reason};}// Determine attendance status (present or late)\nconst attendanceStatus=isLateAttendance(session)?ATTENDANCE_STATUS.LATE:ATTENDANCE_STATUS.PRESENT;// Insert attendance record\nconst{data,error}=await supabase.from('attendance').insert({student_id:studentId,session_id:sessionId,status:attendanceStatus,marked_at:new Date().toISOString()}).select();if(error){// Check for duplicate entry\nif(error.code==='23505'){return{success:false,attendance:null,error:'Attendance already marked'};}throw error;}return{success:true,attendance:data===null||data===void 0?void 0:data[0],error:null,status:attendanceStatus,message:attendanceStatus===ATTENDANCE_STATUS.LATE?'Attendance marked as LATE':'Attendance marked successfully!'};}catch(error){console.error('Error marking attendance:',error);return{success:false,attendance:null,error:error.message};}};/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */export const autoMarkAbsentStudents=async sessionId=>{try{// Get session details\nconst{data:session,error:sessionError}=await supabase.from('sessions').select('*, classes!inner(course_id)').eq('id',sessionId).single();if(sessionError||!session){return{success:false,absentCount:0,error:'Session not found'};}// Check if session is closed\nconst status=calculateSessionStatus(session);if(status!==SESSION_STATUS.CLOSED){return{success:false,absentCount:0,error:'Session is not closed yet'};}// Get all enrolled students for this course\nconst{data:enrollments,error:enrollError}=await supabase.from('enrollments').select('student_id').eq('course_id',session.classes.course_id);if(enrollError){throw enrollError;}// Get students who already marked attendance\nconst{data:presentStudents,error:presentError}=await supabase.from('attendance').select('student_id').eq('session_id',sessionId);if(presentError){throw presentError;}const presentStudentIds=new Set((presentStudents||[]).map(a=>a.student_id));// Find students who didn't mark attendance\nconst absentStudents=(enrollments||[]).filter(e=>!presentStudentIds.has(e.student_id)).map(e=>({student_id:e.student_id,session_id:sessionId,status:ATTENDANCE_STATUS.ABSENT,marked_at:new Date().toISOString()}));if(absentStudents.length===0){return{success:true,absentCount:0,error:null};}// Insert absent records\nconst{error:insertError}=await supabase.from('attendance').insert(absentStudents);if(insertError){throw insertError;}return{success:true,absentCount:absentStudents.length,error:null};}catch(error){console.error('Error auto-marking absent students:',error);return{success:false,absentCount:0,error:error.message};}};/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */export const checkOverlappingSessions=async function(classId,date,startTime,endTime){let excludeSessionId=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;try{let query=supabase.from('sessions').select('id, start_time, end_time').eq('class_id',classId).eq('session_date',date);if(excludeSessionId){query=query.neq('id',excludeSessionId);}const{data:sessions,error}=await query;if(error){throw error;}// Check for time overlaps\nconst overlapping=(sessions||[]).filter(session=>{const existingStart=session.start_time;const existingEnd=session.end_time;// Check if times overlap\nreturn startTime<existingEnd&&endTime>existingStart;});return{hasOverlap:overlapping.length>0,overlappingSessions:overlapping};}catch(error){console.error('Error checking overlapping sessions:',error);return{hasOverlap:false,overlappingSessions:[],error:error.message};}};/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */export const createSessionWithValidation=async(delegateId,classId,sessionDate,startTime,endTime)=>{try{// Validate times\nif(startTime>=endTime){return{session:null,error:'End time must be after start time'};}// Validate start time is not in the past\nconst now=new Date();const sessionDateTime=new Date(sessionDate);const[startHour,startMin]=startTime.split(':').map(Number);sessionDateTime.setHours(startHour,startMin,0,0);const sessionDateTimeUTC=new Date(sessionDateTime.getTime()-1*60*60*1000);const nowUTC=new Date(now.getTime()-now.getTimezoneOffset()*60*1000);if(sessionDateTimeUTC<=nowUTC){return{session:null,error:'Session start time cannot be in the past'};}// Check for overlapping sessions\nconst{hasOverlap,overlappingSessions}=await checkOverlappingSessions(classId,sessionDate,startTime,endTime);if(hasOverlap){return{session:null,error:\"Session overlaps with existing session(s) at \".concat(overlappingSessions.map(s=>s.start_time).join(', '))};}// Generate a unique token\nconst token=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);// Calculate expires_at (same as end time for automatic closure) in UTC\nconst[endHour,endMin]=endTime.split(':');const expiresAt=cameroonToUTC(sessionDate,parseInt(endHour),parseInt(endMin));const{data,error}=await supabase.from('sessions').insert({class_id:classId,session_date:sessionDate,start_time:startTime,end_time:endTime,token,expires_at:expiresAt.toISOString()}).select();if(error)throw error;return{session:data===null||data===void 0?void 0:data[0],error:null};}catch(error){console.error('Error creating session:',error);return{session:null,error:error.message};}};/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */export const getStudentSessionsByStatus=async studentId=>{try{// Get student's enrolled courses\nconst{data:enrollments,error:enrollError}=await supabase.from('enrollments').select('course_id').eq('student_id',studentId);if(enrollError)throw enrollError;const courseIds=(enrollments||[]).map(e=>e.course_id);// Get classes for these courses\nconst{data:classes,error:classError}=await supabase.from('classes').select('id').in('course_id',courseIds);if(classError)throw classError;const classIds=(classes||[]).map(c=>c.id);// Get all sessions for these classes\nconst{data:sessions,error:sessionError}=await supabase.from('sessions').select(\"\\n        id,\\n        session_date,\\n        start_time,\\n        end_time,\\n        token,\\n        expires_at,\\n        classes!inner (\\n          id,\\n          class_name,\\n          courses!inner (course_code, course_title)\\n        )\\n      \").in('class_id',classIds).order('session_date',{ascending:false});if(sessionError)throw sessionError;// Get student's attendance records\nconst{data:attendance,error:attendanceError}=await supabase.from('attendance').select('session_id, status').eq('student_id',studentId);if(attendanceError)throw attendanceError;const attendanceMap=new Map((attendance||[]).map(a=>[a.session_id,a.status]));// Categorize sessions by status\nconst scheduled=[];const open=[];const closed=[];for(const session of sessions||[]){var _session$classes,_session$classes$cour,_session$classes2,_session$classes2$cou,_session$classes3;const status=calculateSessionStatus(session);const isMarked=attendanceMap.has(session.id);const attendanceStatus=attendanceMap.get(session.id);const enrichedSession={id:session.id,courseCode:(_session$classes=session.classes)===null||_session$classes===void 0?void 0:(_session$classes$cour=_session$classes.courses)===null||_session$classes$cour===void 0?void 0:_session$classes$cour.course_code,courseTitle:(_session$classes2=session.classes)===null||_session$classes2===void 0?void 0:(_session$classes2$cou=_session$classes2.courses)===null||_session$classes2$cou===void 0?void 0:_session$classes2$cou.course_title,className:(_session$classes3=session.classes)===null||_session$classes3===void 0?void 0:_session$classes3.class_name,date:new Date(session.session_date).toLocaleDateString(),startTime:session.start_time,endTime:session.end_time,status,isMarked,attendanceStatus,token:session.token};switch(status){case SESSION_STATUS.SCHEDULED:scheduled.push(enrichedSession);break;case SESSION_STATUS.OPEN:open.push(enrichedSession);break;case SESSION_STATUS.CLOSED:closed.push(enrichedSession);break;}}return{scheduled,open,closed,error:null};}catch(error){console.error('Error fetching student sessions:',error);return{scheduled:[],open:[],closed:[],error:error.message};}};/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */export const getDelegateSessionsByStatus=async delegateId=>{try{// Get delegate's classes\nconst{data:classes,error:classError}=await supabase.from('classes').select('id').eq('delegate_id',delegateId);if(classError)throw classError;const classIds=(classes||[]).map(c=>c.id);// Get all sessions for these classes\nconst{data:sessions,error:sessionError}=await supabase.from('sessions').select(\"\\n        id,\\n        session_date,\\n        start_time,\\n        end_time,\\n        token,\\n        expires_at,\\n        classes!inner (\\n          id,\\n          class_name,\\n          courses!inner (course_code, course_title)\\n        )\\n      \").in('class_id',classIds).order('session_date',{ascending:false});if(sessionError)throw sessionError;// Get attendance counts for each session\nconst sessionIds=(sessions||[]).map(s=>s.id);const{data:attendanceCounts,error:countError}=await supabase.from('attendance').select('session_id').in('session_id',sessionIds);// Count attendance per session\nconst countMap=new Map();(attendanceCounts||[]).forEach(a=>{countMap.set(a.session_id,(countMap.get(a.session_id)||0)+1);});// Categorize sessions by status\nconst scheduled=[];const open=[];const closed=[];for(const session of sessions||[]){var _session$classes4,_session$classes4$cou,_session$classes5,_session$classes5$cou,_session$classes6;const status=calculateSessionStatus(session);const enrichedSession={id:session.id,courseCode:(_session$classes4=session.classes)===null||_session$classes4===void 0?void 0:(_session$classes4$cou=_session$classes4.courses)===null||_session$classes4$cou===void 0?void 0:_session$classes4$cou.course_code,courseTitle:(_session$classes5=session.classes)===null||_session$classes5===void 0?void 0:(_session$classes5$cou=_session$classes5.courses)===null||_session$classes5$cou===void 0?void 0:_session$classes5$cou.course_title,className:(_session$classes6=session.classes)===null||_session$classes6===void 0?void 0:_session$classes6.class_name,date:new Date(session.session_date).toLocaleDateString(),startTime:session.start_time,endTime:session.end_time,status,attendanceCount:countMap.get(session.id)||0,token:session.token};switch(status){case SESSION_STATUS.SCHEDULED:scheduled.push(enrichedSession);break;case SESSION_STATUS.OPEN:open.push(enrichedSession);break;case SESSION_STATUS.CLOSED:closed.push(enrichedSession);break;}}return{scheduled,open,closed,error:null};}catch(error){console.error('Error fetching delegate sessions:',error);return{scheduled:[],open:[],closed:[],error:error.message};}};/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */export const processSessionClosure=async sessionId=>{try{// Auto-mark absent students\nconst result=await autoMarkAbsentStudents(sessionId);if(!result.success){console.error('Failed to auto-mark absent students:',result.error);}else{console.log(\"Session \".concat(sessionId,\" closed. \").concat(result.absentCount,\" students marked absent.\"));}return result;}catch(error){console.error('Error processing session closure:',error);return{success:false,error:error.message};}};/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */export const getTimeRemaining=session=>{const now=new Date();// Handle different property names\nconst sessionDate=session.session_date||session.date;const startTime=session.start_time||session.startTime;const endTime=session.end_time||session.endTime;const[startHour,startMin]=startTime.split(':').map(Number);const[endHour,endMin]=endTime.split(':').map(Number);const startDateTimeUTC=cameroonToUTC(sessionDate,startHour,startMin);const endDateTimeUTC=cameroonToUTC(sessionDate,endHour,endMin);const nowUTC=new Date(now.getTime()-now.getTimezoneOffset()*60*1000);if(nowUTC<startDateTimeUTC){const diffMs=startDateTimeUTC-nowUTC;const minutes=Math.floor(diffMs/60000);const hours=Math.floor(minutes/60);const mins=minutes%60;return{type:'start',minutes,formatted:hours>0?\"\".concat(hours,\"h \").concat(mins,\"m until start\"):\"\".concat(mins,\"m until start\")};}else if(nowUTC<endDateTimeUTC){const diffMs=endDateTimeUTC-nowUTC;const minutes=Math.floor(diffMs/60000);const hours=Math.floor(minutes/60);const mins=minutes%60;return{type:'end',minutes,formatted:hours>0?\"\".concat(hours,\"h \").concat(mins,\"m remaining\"):\"\".concat(mins,\"m remaining\")};}return{type:'ended',minutes:0,formatted:'Session ended'};};","map":{"version":3,"names":["supabase","SESSION_STATUS","SCHEDULED","OPEN","CLOSED","ATTENDANCE_STATUS","PRESENT","LATE","ABSENT","LATE_WINDOW_MINUTES","cameroonToUTC","date","hour","min","cameroonTime","Date","setHours","getTime","utcToCameroon","utcDate","calculateSessionStatus","session","now","sessionDate","session_date","startTime","start_time","endTime","end_time","startHour","startMin","split","map","Number","endHour","endMin","startDateTimeUTC","endDateTimeUTC","nowUTC","getTimezoneOffset","canMarkAttendance","studentId","status","canMark","reason","data","classData","error","classError","from","select","eq","class_id","single","enrollment","enrollError","course_id","existingAttendance","attendanceError","id","isLateAttendance","startDateTime","lateThreshold","setMinutes","getMinutes","markAttendanceWithStatus","sessionId","sessionError","success","attendance","attendanceStatus","insert","student_id","session_id","marked_at","toISOString","code","message","console","autoMarkAbsentStudents","absentCount","enrollments","classes","presentStudents","presentError","presentStudentIds","Set","a","absentStudents","filter","e","has","length","insertError","checkOverlappingSessions","classId","excludeSessionId","arguments","undefined","query","neq","sessions","overlapping","existingStart","existingEnd","hasOverlap","overlappingSessions","createSessionWithValidation","delegateId","sessionDateTime","sessionDateTimeUTC","concat","s","join","token","Math","random","toString","substring","expiresAt","parseInt","expires_at","getStudentSessionsByStatus","courseIds","in","classIds","c","order","ascending","attendanceMap","Map","scheduled","open","closed","_session$classes","_session$classes$cour","_session$classes2","_session$classes2$cou","_session$classes3","isMarked","get","enrichedSession","courseCode","courses","course_code","courseTitle","course_title","className","class_name","toLocaleDateString","push","getDelegateSessionsByStatus","sessionIds","attendanceCounts","countError","countMap","forEach","set","_session$classes4","_session$classes4$cou","_session$classes5","_session$classes5$cou","_session$classes6","attendanceCount","processSessionClosure","result","log","getTimeRemaining","diffMs","minutes","floor","hours","mins","type","formatted"],"sources":["C:/Users/PFI/Desktop/ictuattennce_portal/ATTENDANCE/src/utils/sessionLifecycle.js"],"sourcesContent":["import { supabase } from '../supabase/supabase';\r\n\r\n/**\r\n * Session Lifecycle Management Utilities\r\n * \r\n * Session States:\r\n * - SCHEDULED: Session created but start time not reached\r\n * - OPEN: Session is active, attendance can be marked\r\n * - CLOSED: Session ended, attendance locked\r\n * \r\n * Attendance States:\r\n * - PRESENT: Student marked attendance on time\r\n * - LATE: Student marked attendance after late window (first 10 minutes)\r\n * - ABSENT: Student did not mark attendance before session closed\r\n */\r\n\r\n// Session status constants\r\nexport const SESSION_STATUS = {\r\n    SCHEDULED: 'scheduled',\r\n    OPEN: 'open',\r\n    CLOSED: 'closed'\r\n};\r\n\r\n// Attendance status constants\r\nexport const ATTENDANCE_STATUS = {\r\n    PRESENT: 'present',\r\n    LATE: 'late',\r\n    ABSENT: 'absent'\r\n};\r\n\r\n// Late window in minutes (first 10 minutes after session start)\r\nexport const LATE_WINDOW_MINUTES = 10;\r\n\r\n/**\r\n * Calculate the current status of a session based on server time\r\n * @param {Object} session - Session object with session_date, start_time, end_time\r\n * @returns {string} - Session status (scheduled, open, closed)\r\n */\r\n// Helper function to convert Cameroon time to UTC\r\nconst cameroonToUTC = (date, hour, min) => {\r\n    const cameroonTime = new Date(date);\r\n    cameroonTime.setHours(hour, min, 0, 0);\r\n    // Cameroon is UTC+1, so subtract 1 hour to get UTC\r\n    return new Date(cameroonTime.getTime() - (1 * 60 * 60 * 1000));\r\n};\r\n\r\n// Helper function to convert UTC to Cameroon time\r\nconst utcToCameroon = (utcDate) => {\r\n    // Add 1 hour to UTC to get Cameroon time\r\n    return new Date(utcDate.getTime() + (1 * 60 * 60 * 1000));\r\n};\r\n\r\nexport const calculateSessionStatus = (session) => {\r\n    const now = new Date();\r\n\r\n    // Handle different property names (database vs transformed)\r\n    const sessionDate = session.session_date || session.date;\r\n    const startTime = session.start_time || session.startTime;\r\n    const endTime = session.end_time || session.endTime;\r\n\r\n    // Parse start and end times as Cameroon time, then convert to UTC for comparison\r\n    const [startHour, startMin] = startTime.split(':').map(Number);\r\n    const [endHour, endMin] = endTime.split(':').map(Number);\r\n\r\n    const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\r\n    const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\r\n\r\n    // Convert current time to UTC for comparison\r\n    const nowUTC = new Date(now.getTime() - (now.getTimezoneOffset() * 60 * 1000));\r\n\r\n    // Determine status\r\n    if (nowUTC < startDateTimeUTC) {\r\n        return SESSION_STATUS.SCHEDULED;\r\n    } else if (nowUTC >= startDateTimeUTC && nowUTC <= endDateTimeUTC) {\r\n        return SESSION_STATUS.OPEN;\r\n    } else {\r\n        return SESSION_STATUS.CLOSED;\r\n    }\r\n};\r\n\r\n/**\r\n * Check if a student can mark attendance for a session\r\n * @param {Object} session - Session object\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { canMark: boolean, reason: string, status: string }\r\n */\r\nexport const canMarkAttendance = async (session, studentId) => {\r\n    const status = calculateSessionStatus(session);\r\n\r\n    // Check if session is open\r\n    if (status === SESSION_STATUS.SCHEDULED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has not started yet',\r\n            status\r\n        };\r\n    }\r\n\r\n    if (status === SESSION_STATUS.CLOSED) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Session has ended. Attendance is locked.',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student is enrolled in the course\r\n    const { data: classData, error: classError } = await supabase\r\n        .from('classes')\r\n        .select('course_id')\r\n        .eq('id', session.class_id)\r\n        .single();\r\n\r\n    if (classError || !classData) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'Unable to verify enrollment',\r\n            status\r\n        };\r\n    }\r\n\r\n    const { data: enrollment, error: enrollError } = await supabase\r\n        .from('enrollments')\r\n        .select('id')\r\n        .eq('student_id', studentId)\r\n        .eq('course_id', classData.course_id)\r\n        .single();\r\n\r\n    if (enrollError || !enrollment) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You are not enrolled in this course',\r\n            status\r\n        };\r\n    }\r\n\r\n    // Check if student has already marked attendance\r\n    const { data: existingAttendance, error: attendanceError } = await supabase\r\n        .from('attendance')\r\n        .select('id')\r\n        .eq('session_id', session.id)\r\n        .eq('student_id', studentId)\r\n        .single();\r\n\r\n    if (existingAttendance) {\r\n        return {\r\n            canMark: false,\r\n            reason: 'You have already marked attendance for this session',\r\n            status\r\n        };\r\n    }\r\n\r\n    return {\r\n        canMark: true,\r\n        reason: 'Ready to mark attendance',\r\n        status\r\n    };\r\n};\r\n\r\n/**\r\n * Determine if attendance should be marked as late\r\n * @param {Object} session - Session object\r\n * @returns {boolean} - True if current time is past the late window\r\n */\r\nexport const isLateAttendance = (session) => {\r\n    const now = new Date();\r\n    const sessionDate = session.session_date;\r\n\r\n    const [startHour, startMin] = session.start_time.split(':').map(Number);\r\n\r\n    const startDateTime = new Date(sessionDate);\r\n    startDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n    const lateThreshold = new Date(startDateTime);\r\n    lateThreshold.setMinutes(lateThreshold.getMinutes() + LATE_WINDOW_MINUTES);\r\n\r\n    return now > lateThreshold;\r\n};\r\n\r\n/**\r\n * Mark attendance for a student with proper status\r\n * @param {string} studentId - Student's user ID\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, attendance: Object, error: string }\r\n */\r\nexport const markAttendanceWithStatus = async (studentId, sessionId) => {\r\n    try {\r\n        // First get the session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, attendance: null, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if student can mark attendance\r\n        const { canMark, reason, status } = await canMarkAttendance(session, studentId);\r\n\r\n        if (!canMark) {\r\n            return { success: false, attendance: null, error: reason };\r\n        }\r\n\r\n        // Determine attendance status (present or late)\r\n        const attendanceStatus = isLateAttendance(session)\r\n            ? ATTENDANCE_STATUS.LATE\r\n            : ATTENDANCE_STATUS.PRESENT;\r\n\r\n        // Insert attendance record\r\n        const { data, error } = await supabase\r\n            .from('attendance')\r\n            .insert({\r\n                student_id: studentId,\r\n                session_id: sessionId,\r\n                status: attendanceStatus,\r\n                marked_at: new Date().toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) {\r\n            // Check for duplicate entry\r\n            if (error.code === '23505') {\r\n                return { success: false, attendance: null, error: 'Attendance already marked' };\r\n            }\r\n            throw error;\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            attendance: data?.[0],\r\n            error: null,\r\n            status: attendanceStatus,\r\n            message: attendanceStatus === ATTENDANCE_STATUS.LATE\r\n                ? 'Attendance marked as LATE'\r\n                : 'Attendance marked successfully!'\r\n        };\r\n    } catch (error) {\r\n        console.error('Error marking attendance:', error);\r\n        return { success: false, attendance: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Auto-mark absent students when session closes\r\n * @param {string} sessionId - Session ID\r\n * @returns {Object} - { success: boolean, absentCount: number, error: string }\r\n */\r\nexport const autoMarkAbsentStudents = async (sessionId) => {\r\n    try {\r\n        // Get session details\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*, classes!inner(course_id)')\r\n            .eq('id', sessionId)\r\n            .single();\r\n\r\n        if (sessionError || !session) {\r\n            return { success: false, absentCount: 0, error: 'Session not found' };\r\n        }\r\n\r\n        // Check if session is closed\r\n        const status = calculateSessionStatus(session);\r\n        if (status !== SESSION_STATUS.CLOSED) {\r\n            return { success: false, absentCount: 0, error: 'Session is not closed yet' };\r\n        }\r\n\r\n        // Get all enrolled students for this course\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('student_id')\r\n            .eq('course_id', session.classes.course_id);\r\n\r\n        if (enrollError) {\r\n            throw enrollError;\r\n        }\r\n\r\n        // Get students who already marked attendance\r\n        const { data: presentStudents, error: presentError } = await supabase\r\n            .from('attendance')\r\n            .select('student_id')\r\n            .eq('session_id', sessionId);\r\n\r\n        if (presentError) {\r\n            throw presentError;\r\n        }\r\n\r\n        const presentStudentIds = new Set((presentStudents || []).map(a => a.student_id));\r\n\r\n        // Find students who didn't mark attendance\r\n        const absentStudents = (enrollments || [])\r\n            .filter(e => !presentStudentIds.has(e.student_id))\r\n            .map(e => ({\r\n                student_id: e.student_id,\r\n                session_id: sessionId,\r\n                status: ATTENDANCE_STATUS.ABSENT,\r\n                marked_at: new Date().toISOString()\r\n            }));\r\n\r\n        if (absentStudents.length === 0) {\r\n            return { success: true, absentCount: 0, error: null };\r\n        }\r\n\r\n        // Insert absent records\r\n        const { error: insertError } = await supabase\r\n            .from('attendance')\r\n            .insert(absentStudents);\r\n\r\n        if (insertError) {\r\n            throw insertError;\r\n        }\r\n\r\n        return { success: true, absentCount: absentStudents.length, error: null };\r\n    } catch (error) {\r\n        console.error('Error auto-marking absent students:', error);\r\n        return { success: false, absentCount: 0, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Check for overlapping sessions for a class\r\n * @param {string} classId - Class ID\r\n * @param {string} date - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @param {string} excludeSessionId - Optional session ID to exclude (for updates)\r\n * @returns {Object} - { hasOverlap: boolean, overlappingSessions: Array }\r\n */\r\nexport const checkOverlappingSessions = async (classId, date, startTime, endTime, excludeSessionId = null) => {\r\n    try {\r\n        let query = supabase\r\n            .from('sessions')\r\n            .select('id, start_time, end_time')\r\n            .eq('class_id', classId)\r\n            .eq('session_date', date);\r\n\r\n        if (excludeSessionId) {\r\n            query = query.neq('id', excludeSessionId);\r\n        }\r\n\r\n        const { data: sessions, error } = await query;\r\n\r\n        if (error) {\r\n            throw error;\r\n        }\r\n\r\n        // Check for time overlaps\r\n        const overlapping = (sessions || []).filter(session => {\r\n            const existingStart = session.start_time;\r\n            const existingEnd = session.end_time;\r\n\r\n            // Check if times overlap\r\n            return (startTime < existingEnd && endTime > existingStart);\r\n        });\r\n\r\n        return {\r\n            hasOverlap: overlapping.length > 0,\r\n            overlappingSessions: overlapping\r\n        };\r\n    } catch (error) {\r\n        console.error('Error checking overlapping sessions:', error);\r\n        return { hasOverlap: false, overlappingSessions: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Create a session with overlap protection\r\n * @param {string} delegateId - Delegate's user ID\r\n * @param {string} classId - Class ID\r\n * @param {string} sessionDate - Session date (YYYY-MM-DD)\r\n * @param {string} startTime - Start time (HH:MM)\r\n * @param {string} endTime - End time (HH:MM)\r\n * @returns {Object} - { session: Object, error: string }\r\n */\r\nexport const createSessionWithValidation = async (delegateId, classId, sessionDate, startTime, endTime) => {\r\n    try {\r\n        // Validate times\r\n        if (startTime >= endTime) {\r\n            return {\r\n                session: null,\r\n                error: 'End time must be after start time'\r\n            };\r\n        }\r\n\r\n        // Validate start time is not in the past\r\n        const now = new Date();\r\n        const sessionDateTime = new Date(sessionDate);\r\n        const [startHour, startMin] = startTime.split(':').map(Number);\r\n        sessionDateTime.setHours(startHour, startMin, 0, 0);\r\n\r\n        const sessionDateTimeUTC = new Date(sessionDateTime.getTime() - (1 * 60 * 60 * 1000));\r\n        const nowUTC = new Date(now.getTime() - (now.getTimezoneOffset() * 60 * 1000));\r\n\r\n        if (sessionDateTimeUTC <= nowUTC) {\r\n            return {\r\n                session: null,\r\n                error: 'Session start time cannot be in the past'\r\n            };\r\n        }\r\n\r\n        // Check for overlapping sessions\r\n        const { hasOverlap, overlappingSessions } = await checkOverlappingSessions(\r\n            classId, sessionDate, startTime, endTime\r\n        );\r\n\r\n        if (hasOverlap) {\r\n            return {\r\n                session: null,\r\n                error: `Session overlaps with existing session(s) at ${overlappingSessions.map(s => s.start_time).join(', ')}`\r\n            };\r\n        }\r\n\r\n        // Generate a unique token\r\n        const token = Math.random().toString(36).substring(2, 15) +\r\n            Math.random().toString(36).substring(2, 15);\r\n\r\n        // Calculate expires_at (same as end time for automatic closure) in UTC\r\n        const [endHour, endMin] = endTime.split(':');\r\n        const expiresAt = cameroonToUTC(sessionDate, parseInt(endHour), parseInt(endMin));\r\n\r\n        const { data, error } = await supabase\r\n            .from('sessions')\r\n            .insert({\r\n                class_id: classId,\r\n                session_date: sessionDate,\r\n                start_time: startTime,\r\n                end_time: endTime,\r\n                token,\r\n                expires_at: expiresAt.toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (error) throw error;\r\n\r\n        return { session: data?.[0], error: null };\r\n    } catch (error) {\r\n        console.error('Error creating session:', error);\r\n        return { session: null, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a student\r\n * @param {string} studentId - Student's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getStudentSessionsByStatus = async (studentId) => {\r\n    try {\r\n        // Get student's enrolled courses\r\n        const { data: enrollments, error: enrollError } = await supabase\r\n            .from('enrollments')\r\n            .select('course_id')\r\n            .eq('student_id', studentId);\r\n\r\n        if (enrollError) throw enrollError;\r\n\r\n        const courseIds = (enrollments || []).map(e => e.course_id);\r\n\r\n        // Get classes for these courses\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .in('course_id', courseIds);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get student's attendance records\r\n        const { data: attendance, error: attendanceError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id, status')\r\n            .eq('student_id', studentId);\r\n\r\n        if (attendanceError) throw attendanceError;\r\n\r\n        const attendanceMap = new Map(\r\n            (attendance || []).map(a => [a.session_id, a.status])\r\n        );\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n            const isMarked = attendanceMap.has(session.id);\r\n            const attendanceStatus = attendanceMap.get(session.id);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                isMarked,\r\n                attendanceStatus,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching student sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get sessions with calculated status for a delegate\r\n * @param {string} delegateId - Delegate's user ID\r\n * @returns {Object} - { scheduled: Array, open: Array, closed: Array }\r\n */\r\nexport const getDelegateSessionsByStatus = async (delegateId) => {\r\n    try {\r\n        // Get delegate's classes\r\n        const { data: classes, error: classError } = await supabase\r\n            .from('classes')\r\n            .select('id')\r\n            .eq('delegate_id', delegateId);\r\n\r\n        if (classError) throw classError;\r\n\r\n        const classIds = (classes || []).map(c => c.id);\r\n\r\n        // Get all sessions for these classes\r\n        const { data: sessions, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select(`\r\n        id,\r\n        session_date,\r\n        start_time,\r\n        end_time,\r\n        token,\r\n        expires_at,\r\n        classes!inner (\r\n          id,\r\n          class_name,\r\n          courses!inner (course_code, course_title)\r\n        )\r\n      `)\r\n            .in('class_id', classIds)\r\n            .order('session_date', { ascending: false });\r\n\r\n        if (sessionError) throw sessionError;\r\n\r\n        // Get attendance counts for each session\r\n        const sessionIds = (sessions || []).map(s => s.id);\r\n        const { data: attendanceCounts, error: countError } = await supabase\r\n            .from('attendance')\r\n            .select('session_id')\r\n            .in('session_id', sessionIds);\r\n\r\n        // Count attendance per session\r\n        const countMap = new Map();\r\n        (attendanceCounts || []).forEach(a => {\r\n            countMap.set(a.session_id, (countMap.get(a.session_id) || 0) + 1);\r\n        });\r\n\r\n        // Categorize sessions by status\r\n        const scheduled = [];\r\n        const open = [];\r\n        const closed = [];\r\n\r\n        for (const session of (sessions || [])) {\r\n            const status = calculateSessionStatus(session);\r\n\r\n            const enrichedSession = {\r\n                id: session.id,\r\n                courseCode: session.classes?.courses?.course_code,\r\n                courseTitle: session.classes?.courses?.course_title,\r\n                className: session.classes?.class_name,\r\n                date: new Date(session.session_date).toLocaleDateString(),\r\n                startTime: session.start_time,\r\n                endTime: session.end_time,\r\n                status,\r\n                attendanceCount: countMap.get(session.id) || 0,\r\n                token: session.token\r\n            };\r\n\r\n            switch (status) {\r\n                case SESSION_STATUS.SCHEDULED:\r\n                    scheduled.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.OPEN:\r\n                    open.push(enrichedSession);\r\n                    break;\r\n                case SESSION_STATUS.CLOSED:\r\n                    closed.push(enrichedSession);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return { scheduled, open, closed, error: null };\r\n    } catch (error) {\r\n        console.error('Error fetching delegate sessions:', error);\r\n        return { scheduled: [], open: [], closed: [], error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Process session closure - auto-mark absent students\r\n * This should be called when a session transitions to CLOSED status\r\n * @param {string} sessionId - Session ID\r\n */\r\nexport const processSessionClosure = async (sessionId) => {\r\n    try {\r\n        // Auto-mark absent students\r\n        const result = await autoMarkAbsentStudents(sessionId);\r\n\r\n        if (!result.success) {\r\n            console.error('Failed to auto-mark absent students:', result.error);\r\n        } else {\r\n            console.log(`Session ${sessionId} closed. ${result.absentCount} students marked absent.`);\r\n        }\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error processing session closure:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n};\r\n\r\n/**\r\n * Get time remaining until session starts or ends\r\n * @param {Object} session - Session object\r\n * @returns {Object} - { type: 'start'|'end', minutes: number, formatted: string }\r\n */\r\nexport const getTimeRemaining = (session) => {\r\n    const now = new Date();\r\n\r\n    // Handle different property names\r\n    const sessionDate = session.session_date || session.date;\r\n    const startTime = session.start_time || session.startTime;\r\n    const endTime = session.end_time || session.endTime;\r\n\r\n    const [startHour, startMin] = startTime.split(':').map(Number);\r\n    const [endHour, endMin] = endTime.split(':').map(Number);\r\n\r\n    const startDateTimeUTC = cameroonToUTC(sessionDate, startHour, startMin);\r\n    const endDateTimeUTC = cameroonToUTC(sessionDate, endHour, endMin);\r\n    const nowUTC = new Date(now.getTime() - (now.getTimezoneOffset() * 60 * 1000));\r\n\r\n    if (nowUTC < startDateTimeUTC) {\r\n        const diffMs = startDateTimeUTC - nowUTC;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'start',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m until start` : `${mins}m until start`\r\n        };\r\n    } else if (nowUTC < endDateTimeUTC) {\r\n        const diffMs = endDateTimeUTC - nowUTC;\r\n        const minutes = Math.floor(diffMs / 60000);\r\n        const hours = Math.floor(minutes / 60);\r\n        const mins = minutes % 60;\r\n\r\n        return {\r\n            type: 'end',\r\n            minutes,\r\n            formatted: hours > 0 ? `${hours}h ${mins}m remaining` : `${mins}m remaining`\r\n        };\r\n    }\r\n\r\n    return {\r\n        type: 'ended',\r\n        minutes: 0,\r\n        formatted: 'Session ended'\r\n    };\r\n};\r\n"],"mappings":"AAAA,OAASA,QAAQ,KAAQ,sBAAsB,CAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA;AACA,MAAO,MAAM,CAAAC,cAAc,CAAG,CAC1BC,SAAS,CAAE,WAAW,CACtBC,IAAI,CAAE,MAAM,CACZC,MAAM,CAAE,QACZ,CAAC,CAED;AACA,MAAO,MAAM,CAAAC,iBAAiB,CAAG,CAC7BC,OAAO,CAAE,SAAS,CAClBC,IAAI,CAAE,MAAM,CACZC,MAAM,CAAE,QACZ,CAAC,CAED;AACA,MAAO,MAAM,CAAAC,mBAAmB,CAAG,EAAE,CAErC;AACA;AACA;AACA;AACA,GACA;AACA,KAAM,CAAAC,aAAa,CAAGA,CAACC,IAAI,CAAEC,IAAI,CAAEC,GAAG,GAAK,CACvC,KAAM,CAAAC,YAAY,CAAG,GAAI,CAAAC,IAAI,CAACJ,IAAI,CAAC,CACnCG,YAAY,CAACE,QAAQ,CAACJ,IAAI,CAAEC,GAAG,CAAE,CAAC,CAAE,CAAC,CAAC,CACtC;AACA,MAAO,IAAI,CAAAE,IAAI,CAACD,YAAY,CAACG,OAAO,CAAC,CAAC,CAAI,CAAC,CAAG,EAAE,CAAG,EAAE,CAAG,IAAK,CAAC,CAClE,CAAC,CAED;AACA,KAAM,CAAAC,aAAa,CAAIC,OAAO,EAAK,CAC/B;AACA,MAAO,IAAI,CAAAJ,IAAI,CAACI,OAAO,CAACF,OAAO,CAAC,CAAC,CAAI,CAAC,CAAG,EAAE,CAAG,EAAE,CAAG,IAAK,CAAC,CAC7D,CAAC,CAED,MAAO,MAAM,CAAAG,sBAAsB,CAAIC,OAAO,EAAK,CAC/C,KAAM,CAAAC,GAAG,CAAG,GAAI,CAAAP,IAAI,CAAC,CAAC,CAEtB;AACA,KAAM,CAAAQ,WAAW,CAAGF,OAAO,CAACG,YAAY,EAAIH,OAAO,CAACV,IAAI,CACxD,KAAM,CAAAc,SAAS,CAAGJ,OAAO,CAACK,UAAU,EAAIL,OAAO,CAACI,SAAS,CACzD,KAAM,CAAAE,OAAO,CAAGN,OAAO,CAACO,QAAQ,EAAIP,OAAO,CAACM,OAAO,CAEnD;AACA,KAAM,CAACE,SAAS,CAAEC,QAAQ,CAAC,CAAGL,SAAS,CAACM,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAC9D,KAAM,CAACC,OAAO,CAAEC,MAAM,CAAC,CAAGR,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAExD,KAAM,CAAAG,gBAAgB,CAAG1B,aAAa,CAACa,WAAW,CAAEM,SAAS,CAAEC,QAAQ,CAAC,CACxE,KAAM,CAAAO,cAAc,CAAG3B,aAAa,CAACa,WAAW,CAAEW,OAAO,CAAEC,MAAM,CAAC,CAElE;AACA,KAAM,CAAAG,MAAM,CAAG,GAAI,CAAAvB,IAAI,CAACO,GAAG,CAACL,OAAO,CAAC,CAAC,CAAIK,GAAG,CAACiB,iBAAiB,CAAC,CAAC,CAAG,EAAE,CAAG,IAAK,CAAC,CAE9E;AACA,GAAID,MAAM,CAAGF,gBAAgB,CAAE,CAC3B,MAAO,CAAAnC,cAAc,CAACC,SAAS,CACnC,CAAC,IAAM,IAAIoC,MAAM,EAAIF,gBAAgB,EAAIE,MAAM,EAAID,cAAc,CAAE,CAC/D,MAAO,CAAApC,cAAc,CAACE,IAAI,CAC9B,CAAC,IAAM,CACH,MAAO,CAAAF,cAAc,CAACG,MAAM,CAChC,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAoC,iBAAiB,CAAG,KAAAA,CAAOnB,OAAO,CAAEoB,SAAS,GAAK,CAC3D,KAAM,CAAAC,MAAM,CAAGtB,sBAAsB,CAACC,OAAO,CAAC,CAE9C;AACA,GAAIqB,MAAM,GAAKzC,cAAc,CAACC,SAAS,CAAE,CACrC,MAAO,CACHyC,OAAO,CAAE,KAAK,CACdC,MAAM,CAAE,6BAA6B,CACrCF,MACJ,CAAC,CACL,CAEA,GAAIA,MAAM,GAAKzC,cAAc,CAACG,MAAM,CAAE,CAClC,MAAO,CACHuC,OAAO,CAAE,KAAK,CACdC,MAAM,CAAE,0CAA0C,CAClDF,MACJ,CAAC,CACL,CAEA;AACA,KAAM,CAAEG,IAAI,CAAEC,SAAS,CAAEC,KAAK,CAAEC,UAAW,CAAC,CAAG,KAAM,CAAAhD,QAAQ,CACxDiD,IAAI,CAAC,SAAS,CAAC,CACfC,MAAM,CAAC,WAAW,CAAC,CACnBC,EAAE,CAAC,IAAI,CAAE9B,OAAO,CAAC+B,QAAQ,CAAC,CAC1BC,MAAM,CAAC,CAAC,CAEb,GAAIL,UAAU,EAAI,CAACF,SAAS,CAAE,CAC1B,MAAO,CACHH,OAAO,CAAE,KAAK,CACdC,MAAM,CAAE,6BAA6B,CACrCF,MACJ,CAAC,CACL,CAEA,KAAM,CAAEG,IAAI,CAAES,UAAU,CAAEP,KAAK,CAAEQ,WAAY,CAAC,CAAG,KAAM,CAAAvD,QAAQ,CAC1DiD,IAAI,CAAC,aAAa,CAAC,CACnBC,MAAM,CAAC,IAAI,CAAC,CACZC,EAAE,CAAC,YAAY,CAAEV,SAAS,CAAC,CAC3BU,EAAE,CAAC,WAAW,CAAEL,SAAS,CAACU,SAAS,CAAC,CACpCH,MAAM,CAAC,CAAC,CAEb,GAAIE,WAAW,EAAI,CAACD,UAAU,CAAE,CAC5B,MAAO,CACHX,OAAO,CAAE,KAAK,CACdC,MAAM,CAAE,qCAAqC,CAC7CF,MACJ,CAAC,CACL,CAEA;AACA,KAAM,CAAEG,IAAI,CAAEY,kBAAkB,CAAEV,KAAK,CAAEW,eAAgB,CAAC,CAAG,KAAM,CAAA1D,QAAQ,CACtEiD,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,IAAI,CAAC,CACZC,EAAE,CAAC,YAAY,CAAE9B,OAAO,CAACsC,EAAE,CAAC,CAC5BR,EAAE,CAAC,YAAY,CAAEV,SAAS,CAAC,CAC3BY,MAAM,CAAC,CAAC,CAEb,GAAII,kBAAkB,CAAE,CACpB,MAAO,CACHd,OAAO,CAAE,KAAK,CACdC,MAAM,CAAE,qDAAqD,CAC7DF,MACJ,CAAC,CACL,CAEA,MAAO,CACHC,OAAO,CAAE,IAAI,CACbC,MAAM,CAAE,0BAA0B,CAClCF,MACJ,CAAC,CACL,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAkB,gBAAgB,CAAIvC,OAAO,EAAK,CACzC,KAAM,CAAAC,GAAG,CAAG,GAAI,CAAAP,IAAI,CAAC,CAAC,CACtB,KAAM,CAAAQ,WAAW,CAAGF,OAAO,CAACG,YAAY,CAExC,KAAM,CAACK,SAAS,CAAEC,QAAQ,CAAC,CAAGT,OAAO,CAACK,UAAU,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAEvE,KAAM,CAAA4B,aAAa,CAAG,GAAI,CAAA9C,IAAI,CAACQ,WAAW,CAAC,CAC3CsC,aAAa,CAAC7C,QAAQ,CAACa,SAAS,CAAEC,QAAQ,CAAE,CAAC,CAAE,CAAC,CAAC,CAEjD,KAAM,CAAAgC,aAAa,CAAG,GAAI,CAAA/C,IAAI,CAAC8C,aAAa,CAAC,CAC7CC,aAAa,CAACC,UAAU,CAACD,aAAa,CAACE,UAAU,CAAC,CAAC,CAAGvD,mBAAmB,CAAC,CAE1E,MAAO,CAAAa,GAAG,CAAGwC,aAAa,CAC9B,CAAC,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAG,wBAAwB,CAAG,KAAAA,CAAOxB,SAAS,CAAEyB,SAAS,GAAK,CACpE,GAAI,CACA;AACA,KAAM,CAAErB,IAAI,CAAExB,OAAO,CAAE0B,KAAK,CAAEoB,YAAa,CAAC,CAAG,KAAM,CAAAnE,QAAQ,CACxDiD,IAAI,CAAC,UAAU,CAAC,CAChBC,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,IAAI,CAAEe,SAAS,CAAC,CACnBb,MAAM,CAAC,CAAC,CAEb,GAAIc,YAAY,EAAI,CAAC9C,OAAO,CAAE,CAC1B,MAAO,CAAE+C,OAAO,CAAE,KAAK,CAAEC,UAAU,CAAE,IAAI,CAAEtB,KAAK,CAAE,mBAAoB,CAAC,CAC3E,CAEA;AACA,KAAM,CAAEJ,OAAO,CAAEC,MAAM,CAAEF,MAAO,CAAC,CAAG,KAAM,CAAAF,iBAAiB,CAACnB,OAAO,CAAEoB,SAAS,CAAC,CAE/E,GAAI,CAACE,OAAO,CAAE,CACV,MAAO,CAAEyB,OAAO,CAAE,KAAK,CAAEC,UAAU,CAAE,IAAI,CAAEtB,KAAK,CAAEH,MAAO,CAAC,CAC9D,CAEA;AACA,KAAM,CAAA0B,gBAAgB,CAAGV,gBAAgB,CAACvC,OAAO,CAAC,CAC5ChB,iBAAiB,CAACE,IAAI,CACtBF,iBAAiB,CAACC,OAAO,CAE/B;AACA,KAAM,CAAEuC,IAAI,CAAEE,KAAM,CAAC,CAAG,KAAM,CAAA/C,QAAQ,CACjCiD,IAAI,CAAC,YAAY,CAAC,CAClBsB,MAAM,CAAC,CACJC,UAAU,CAAE/B,SAAS,CACrBgC,UAAU,CAAEP,SAAS,CACrBxB,MAAM,CAAE4B,gBAAgB,CACxBI,SAAS,CAAE,GAAI,CAAA3D,IAAI,CAAC,CAAC,CAAC4D,WAAW,CAAC,CACtC,CAAC,CAAC,CACDzB,MAAM,CAAC,CAAC,CAEb,GAAIH,KAAK,CAAE,CACP;AACA,GAAIA,KAAK,CAAC6B,IAAI,GAAK,OAAO,CAAE,CACxB,MAAO,CAAER,OAAO,CAAE,KAAK,CAAEC,UAAU,CAAE,IAAI,CAAEtB,KAAK,CAAE,2BAA4B,CAAC,CACnF,CACA,KAAM,CAAAA,KAAK,CACf,CAEA,MAAO,CACHqB,OAAO,CAAE,IAAI,CACbC,UAAU,CAAExB,IAAI,SAAJA,IAAI,iBAAJA,IAAI,CAAG,CAAC,CAAC,CACrBE,KAAK,CAAE,IAAI,CACXL,MAAM,CAAE4B,gBAAgB,CACxBO,OAAO,CAAEP,gBAAgB,GAAKjE,iBAAiB,CAACE,IAAI,CAC9C,2BAA2B,CAC3B,iCACV,CAAC,CACL,CAAE,MAAOwC,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,MAAO,CAAEqB,OAAO,CAAE,KAAK,CAAEC,UAAU,CAAE,IAAI,CAAEtB,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CACrE,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAE,sBAAsB,CAAG,KAAO,CAAAb,SAAS,EAAK,CACvD,GAAI,CACA;AACA,KAAM,CAAErB,IAAI,CAAExB,OAAO,CAAE0B,KAAK,CAAEoB,YAAa,CAAC,CAAG,KAAM,CAAAnE,QAAQ,CACxDiD,IAAI,CAAC,UAAU,CAAC,CAChBC,MAAM,CAAC,6BAA6B,CAAC,CACrCC,EAAE,CAAC,IAAI,CAAEe,SAAS,CAAC,CACnBb,MAAM,CAAC,CAAC,CAEb,GAAIc,YAAY,EAAI,CAAC9C,OAAO,CAAE,CAC1B,MAAO,CAAE+C,OAAO,CAAE,KAAK,CAAEY,WAAW,CAAE,CAAC,CAAEjC,KAAK,CAAE,mBAAoB,CAAC,CACzE,CAEA;AACA,KAAM,CAAAL,MAAM,CAAGtB,sBAAsB,CAACC,OAAO,CAAC,CAC9C,GAAIqB,MAAM,GAAKzC,cAAc,CAACG,MAAM,CAAE,CAClC,MAAO,CAAEgE,OAAO,CAAE,KAAK,CAAEY,WAAW,CAAE,CAAC,CAAEjC,KAAK,CAAE,2BAA4B,CAAC,CACjF,CAEA;AACA,KAAM,CAAEF,IAAI,CAAEoC,WAAW,CAAElC,KAAK,CAAEQ,WAAY,CAAC,CAAG,KAAM,CAAAvD,QAAQ,CAC3DiD,IAAI,CAAC,aAAa,CAAC,CACnBC,MAAM,CAAC,YAAY,CAAC,CACpBC,EAAE,CAAC,WAAW,CAAE9B,OAAO,CAAC6D,OAAO,CAAC1B,SAAS,CAAC,CAE/C,GAAID,WAAW,CAAE,CACb,KAAM,CAAAA,WAAW,CACrB,CAEA;AACA,KAAM,CAAEV,IAAI,CAAEsC,eAAe,CAAEpC,KAAK,CAAEqC,YAAa,CAAC,CAAG,KAAM,CAAApF,QAAQ,CAChEiD,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,YAAY,CAAC,CACpBC,EAAE,CAAC,YAAY,CAAEe,SAAS,CAAC,CAEhC,GAAIkB,YAAY,CAAE,CACd,KAAM,CAAAA,YAAY,CACtB,CAEA,KAAM,CAAAC,iBAAiB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAACH,eAAe,EAAI,EAAE,EAAEnD,GAAG,CAACuD,CAAC,EAAIA,CAAC,CAACf,UAAU,CAAC,CAAC,CAEjF;AACA,KAAM,CAAAgB,cAAc,CAAG,CAACP,WAAW,EAAI,EAAE,EACpCQ,MAAM,CAACC,CAAC,EAAI,CAACL,iBAAiB,CAACM,GAAG,CAACD,CAAC,CAAClB,UAAU,CAAC,CAAC,CACjDxC,GAAG,CAAC0D,CAAC,GAAK,CACPlB,UAAU,CAAEkB,CAAC,CAAClB,UAAU,CACxBC,UAAU,CAAEP,SAAS,CACrBxB,MAAM,CAAErC,iBAAiB,CAACG,MAAM,CAChCkE,SAAS,CAAE,GAAI,CAAA3D,IAAI,CAAC,CAAC,CAAC4D,WAAW,CAAC,CACtC,CAAC,CAAC,CAAC,CAEP,GAAIa,cAAc,CAACI,MAAM,GAAK,CAAC,CAAE,CAC7B,MAAO,CAAExB,OAAO,CAAE,IAAI,CAAEY,WAAW,CAAE,CAAC,CAAEjC,KAAK,CAAE,IAAK,CAAC,CACzD,CAEA;AACA,KAAM,CAAEA,KAAK,CAAE8C,WAAY,CAAC,CAAG,KAAM,CAAA7F,QAAQ,CACxCiD,IAAI,CAAC,YAAY,CAAC,CAClBsB,MAAM,CAACiB,cAAc,CAAC,CAE3B,GAAIK,WAAW,CAAE,CACb,KAAM,CAAAA,WAAW,CACrB,CAEA,MAAO,CAAEzB,OAAO,CAAE,IAAI,CAAEY,WAAW,CAAEQ,cAAc,CAACI,MAAM,CAAE7C,KAAK,CAAE,IAAK,CAAC,CAC7E,CAAE,MAAOA,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,qCAAqC,CAAEA,KAAK,CAAC,CAC3D,MAAO,CAAEqB,OAAO,CAAE,KAAK,CAAEY,WAAW,CAAE,CAAC,CAAEjC,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CACnE,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAiB,wBAAwB,CAAG,cAAAA,CAAOC,OAAO,CAAEpF,IAAI,CAAEc,SAAS,CAAEE,OAAO,CAA8B,IAA5B,CAAAqE,gBAAgB,CAAAC,SAAA,CAAAL,MAAA,IAAAK,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAAG,IAAI,CACrG,GAAI,CACA,GAAI,CAAAE,KAAK,CAAGnG,QAAQ,CACfiD,IAAI,CAAC,UAAU,CAAC,CAChBC,MAAM,CAAC,0BAA0B,CAAC,CAClCC,EAAE,CAAC,UAAU,CAAE4C,OAAO,CAAC,CACvB5C,EAAE,CAAC,cAAc,CAAExC,IAAI,CAAC,CAE7B,GAAIqF,gBAAgB,CAAE,CAClBG,KAAK,CAAGA,KAAK,CAACC,GAAG,CAAC,IAAI,CAAEJ,gBAAgB,CAAC,CAC7C,CAEA,KAAM,CAAEnD,IAAI,CAAEwD,QAAQ,CAAEtD,KAAM,CAAC,CAAG,KAAM,CAAAoD,KAAK,CAE7C,GAAIpD,KAAK,CAAE,CACP,KAAM,CAAAA,KAAK,CACf,CAEA;AACA,KAAM,CAAAuD,WAAW,CAAG,CAACD,QAAQ,EAAI,EAAE,EAAEZ,MAAM,CAACpE,OAAO,EAAI,CACnD,KAAM,CAAAkF,aAAa,CAAGlF,OAAO,CAACK,UAAU,CACxC,KAAM,CAAA8E,WAAW,CAAGnF,OAAO,CAACO,QAAQ,CAEpC;AACA,MAAQ,CAAAH,SAAS,CAAG+E,WAAW,EAAI7E,OAAO,CAAG4E,aAAa,CAC9D,CAAC,CAAC,CAEF,MAAO,CACHE,UAAU,CAAEH,WAAW,CAACV,MAAM,CAAG,CAAC,CAClCc,mBAAmB,CAAEJ,WACzB,CAAC,CACL,CAAE,MAAOvD,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,sCAAsC,CAAEA,KAAK,CAAC,CAC5D,MAAO,CAAE0D,UAAU,CAAE,KAAK,CAAEC,mBAAmB,CAAE,EAAE,CAAE3D,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CAC/E,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAA8B,2BAA2B,CAAG,KAAAA,CAAOC,UAAU,CAAEb,OAAO,CAAExE,WAAW,CAAEE,SAAS,CAAEE,OAAO,GAAK,CACvG,GAAI,CACA;AACA,GAAIF,SAAS,EAAIE,OAAO,CAAE,CACtB,MAAO,CACHN,OAAO,CAAE,IAAI,CACb0B,KAAK,CAAE,mCACX,CAAC,CACL,CAEA;AACA,KAAM,CAAAzB,GAAG,CAAG,GAAI,CAAAP,IAAI,CAAC,CAAC,CACtB,KAAM,CAAA8F,eAAe,CAAG,GAAI,CAAA9F,IAAI,CAACQ,WAAW,CAAC,CAC7C,KAAM,CAACM,SAAS,CAAEC,QAAQ,CAAC,CAAGL,SAAS,CAACM,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAC9D4E,eAAe,CAAC7F,QAAQ,CAACa,SAAS,CAAEC,QAAQ,CAAE,CAAC,CAAE,CAAC,CAAC,CAEnD,KAAM,CAAAgF,kBAAkB,CAAG,GAAI,CAAA/F,IAAI,CAAC8F,eAAe,CAAC5F,OAAO,CAAC,CAAC,CAAI,CAAC,CAAG,EAAE,CAAG,EAAE,CAAG,IAAK,CAAC,CACrF,KAAM,CAAAqB,MAAM,CAAG,GAAI,CAAAvB,IAAI,CAACO,GAAG,CAACL,OAAO,CAAC,CAAC,CAAIK,GAAG,CAACiB,iBAAiB,CAAC,CAAC,CAAG,EAAE,CAAG,IAAK,CAAC,CAE9E,GAAIuE,kBAAkB,EAAIxE,MAAM,CAAE,CAC9B,MAAO,CACHjB,OAAO,CAAE,IAAI,CACb0B,KAAK,CAAE,0CACX,CAAC,CACL,CAEA;AACA,KAAM,CAAE0D,UAAU,CAAEC,mBAAoB,CAAC,CAAG,KAAM,CAAAZ,wBAAwB,CACtEC,OAAO,CAAExE,WAAW,CAAEE,SAAS,CAAEE,OACrC,CAAC,CAED,GAAI8E,UAAU,CAAE,CACZ,MAAO,CACHpF,OAAO,CAAE,IAAI,CACb0B,KAAK,iDAAAgE,MAAA,CAAkDL,mBAAmB,CAAC1E,GAAG,CAACgF,CAAC,EAAIA,CAAC,CAACtF,UAAU,CAAC,CAACuF,IAAI,CAAC,IAAI,CAAC,CAChH,CAAC,CACL,CAEA;AACA,KAAM,CAAAC,KAAK,CAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,CAAE,EAAE,CAAC,CACrDH,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,CAAE,EAAE,CAAC,CAE/C;AACA,KAAM,CAACpF,OAAO,CAAEC,MAAM,CAAC,CAAGR,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC,CAC5C,KAAM,CAAAwF,SAAS,CAAG7G,aAAa,CAACa,WAAW,CAAEiG,QAAQ,CAACtF,OAAO,CAAC,CAAEsF,QAAQ,CAACrF,MAAM,CAAC,CAAC,CAEjF,KAAM,CAAEU,IAAI,CAAEE,KAAM,CAAC,CAAG,KAAM,CAAA/C,QAAQ,CACjCiD,IAAI,CAAC,UAAU,CAAC,CAChBsB,MAAM,CAAC,CACJnB,QAAQ,CAAE2C,OAAO,CACjBvE,YAAY,CAAED,WAAW,CACzBG,UAAU,CAAED,SAAS,CACrBG,QAAQ,CAAED,OAAO,CACjBuF,KAAK,CACLO,UAAU,CAAEF,SAAS,CAAC5C,WAAW,CAAC,CACtC,CAAC,CAAC,CACDzB,MAAM,CAAC,CAAC,CAEb,GAAIH,KAAK,CAAE,KAAM,CAAAA,KAAK,CAEtB,MAAO,CAAE1B,OAAO,CAAEwB,IAAI,SAAJA,IAAI,iBAAJA,IAAI,CAAG,CAAC,CAAC,CAAEE,KAAK,CAAE,IAAK,CAAC,CAC9C,CAAE,MAAOA,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,yBAAyB,CAAEA,KAAK,CAAC,CAC/C,MAAO,CAAE1B,OAAO,CAAE,IAAI,CAAE0B,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CAClD,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAA6C,0BAA0B,CAAG,KAAO,CAAAjF,SAAS,EAAK,CAC3D,GAAI,CACA;AACA,KAAM,CAAEI,IAAI,CAAEoC,WAAW,CAAElC,KAAK,CAAEQ,WAAY,CAAC,CAAG,KAAM,CAAAvD,QAAQ,CAC3DiD,IAAI,CAAC,aAAa,CAAC,CACnBC,MAAM,CAAC,WAAW,CAAC,CACnBC,EAAE,CAAC,YAAY,CAAEV,SAAS,CAAC,CAEhC,GAAIc,WAAW,CAAE,KAAM,CAAAA,WAAW,CAElC,KAAM,CAAAoE,SAAS,CAAG,CAAC1C,WAAW,EAAI,EAAE,EAAEjD,GAAG,CAAC0D,CAAC,EAAIA,CAAC,CAAClC,SAAS,CAAC,CAE3D;AACA,KAAM,CAAEX,IAAI,CAAEqC,OAAO,CAAEnC,KAAK,CAAEC,UAAW,CAAC,CAAG,KAAM,CAAAhD,QAAQ,CACtDiD,IAAI,CAAC,SAAS,CAAC,CACfC,MAAM,CAAC,IAAI,CAAC,CACZ0E,EAAE,CAAC,WAAW,CAAED,SAAS,CAAC,CAE/B,GAAI3E,UAAU,CAAE,KAAM,CAAAA,UAAU,CAEhC,KAAM,CAAA6E,QAAQ,CAAG,CAAC3C,OAAO,EAAI,EAAE,EAAElD,GAAG,CAAC8F,CAAC,EAAIA,CAAC,CAACnE,EAAE,CAAC,CAE/C;AACA,KAAM,CAAEd,IAAI,CAAEwD,QAAQ,CAAEtD,KAAK,CAAEoB,YAAa,CAAC,CAAG,KAAM,CAAAnE,QAAQ,CACzDiD,IAAI,CAAC,UAAU,CAAC,CAChBC,MAAM,2PAYZ,CAAC,CACK0E,EAAE,CAAC,UAAU,CAAEC,QAAQ,CAAC,CACxBE,KAAK,CAAC,cAAc,CAAE,CAAEC,SAAS,CAAE,KAAM,CAAC,CAAC,CAEhD,GAAI7D,YAAY,CAAE,KAAM,CAAAA,YAAY,CAEpC;AACA,KAAM,CAAEtB,IAAI,CAAEwB,UAAU,CAAEtB,KAAK,CAAEW,eAAgB,CAAC,CAAG,KAAM,CAAA1D,QAAQ,CAC9DiD,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,oBAAoB,CAAC,CAC5BC,EAAE,CAAC,YAAY,CAAEV,SAAS,CAAC,CAEhC,GAAIiB,eAAe,CAAE,KAAM,CAAAA,eAAe,CAE1C,KAAM,CAAAuE,aAAa,CAAG,GAAI,CAAAC,GAAG,CACzB,CAAC7D,UAAU,EAAI,EAAE,EAAErC,GAAG,CAACuD,CAAC,EAAI,CAACA,CAAC,CAACd,UAAU,CAAEc,CAAC,CAAC7C,MAAM,CAAC,CACxD,CAAC,CAED;AACA,KAAM,CAAAyF,SAAS,CAAG,EAAE,CACpB,KAAM,CAAAC,IAAI,CAAG,EAAE,CACf,KAAM,CAAAC,MAAM,CAAG,EAAE,CAEjB,IAAK,KAAM,CAAAhH,OAAO,GAAK,CAAAgF,QAAQ,EAAI,EAAE,CAAG,KAAAiC,gBAAA,CAAAC,qBAAA,CAAAC,iBAAA,CAAAC,qBAAA,CAAAC,iBAAA,CACpC,KAAM,CAAAhG,MAAM,CAAGtB,sBAAsB,CAACC,OAAO,CAAC,CAC9C,KAAM,CAAAsH,QAAQ,CAAGV,aAAa,CAACtC,GAAG,CAACtE,OAAO,CAACsC,EAAE,CAAC,CAC9C,KAAM,CAAAW,gBAAgB,CAAG2D,aAAa,CAACW,GAAG,CAACvH,OAAO,CAACsC,EAAE,CAAC,CAEtD,KAAM,CAAAkF,eAAe,CAAG,CACpBlF,EAAE,CAAEtC,OAAO,CAACsC,EAAE,CACdmF,UAAU,EAAAR,gBAAA,CAAEjH,OAAO,CAAC6D,OAAO,UAAAoD,gBAAA,kBAAAC,qBAAA,CAAfD,gBAAA,CAAiBS,OAAO,UAAAR,qBAAA,iBAAxBA,qBAAA,CAA0BS,WAAW,CACjDC,WAAW,EAAAT,iBAAA,CAAEnH,OAAO,CAAC6D,OAAO,UAAAsD,iBAAA,kBAAAC,qBAAA,CAAfD,iBAAA,CAAiBO,OAAO,UAAAN,qBAAA,iBAAxBA,qBAAA,CAA0BS,YAAY,CACnDC,SAAS,EAAAT,iBAAA,CAAErH,OAAO,CAAC6D,OAAO,UAAAwD,iBAAA,iBAAfA,iBAAA,CAAiBU,UAAU,CACtCzI,IAAI,CAAE,GAAI,CAAAI,IAAI,CAACM,OAAO,CAACG,YAAY,CAAC,CAAC6H,kBAAkB,CAAC,CAAC,CACzD5H,SAAS,CAAEJ,OAAO,CAACK,UAAU,CAC7BC,OAAO,CAAEN,OAAO,CAACO,QAAQ,CACzBc,MAAM,CACNiG,QAAQ,CACRrE,gBAAgB,CAChB4C,KAAK,CAAE7F,OAAO,CAAC6F,KACnB,CAAC,CAED,OAAQxE,MAAM,EACV,IAAK,CAAAzC,cAAc,CAACC,SAAS,CACzBiI,SAAS,CAACmB,IAAI,CAACT,eAAe,CAAC,CAC/B,MACJ,IAAK,CAAA5I,cAAc,CAACE,IAAI,CACpBiI,IAAI,CAACkB,IAAI,CAACT,eAAe,CAAC,CAC1B,MACJ,IAAK,CAAA5I,cAAc,CAACG,MAAM,CACtBiI,MAAM,CAACiB,IAAI,CAACT,eAAe,CAAC,CAC5B,MACR,CACJ,CAEA,MAAO,CAAEV,SAAS,CAAEC,IAAI,CAAEC,MAAM,CAAEtF,KAAK,CAAE,IAAK,CAAC,CACnD,CAAE,MAAOA,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,MAAO,CAAEoF,SAAS,CAAE,EAAE,CAAEC,IAAI,CAAE,EAAE,CAAEC,MAAM,CAAE,EAAE,CAAEtF,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CACxE,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAA0E,2BAA2B,CAAG,KAAO,CAAA3C,UAAU,EAAK,CAC7D,GAAI,CACA;AACA,KAAM,CAAE/D,IAAI,CAAEqC,OAAO,CAAEnC,KAAK,CAAEC,UAAW,CAAC,CAAG,KAAM,CAAAhD,QAAQ,CACtDiD,IAAI,CAAC,SAAS,CAAC,CACfC,MAAM,CAAC,IAAI,CAAC,CACZC,EAAE,CAAC,aAAa,CAAEyD,UAAU,CAAC,CAElC,GAAI5D,UAAU,CAAE,KAAM,CAAAA,UAAU,CAEhC,KAAM,CAAA6E,QAAQ,CAAG,CAAC3C,OAAO,EAAI,EAAE,EAAElD,GAAG,CAAC8F,CAAC,EAAIA,CAAC,CAACnE,EAAE,CAAC,CAE/C;AACA,KAAM,CAAEd,IAAI,CAAEwD,QAAQ,CAAEtD,KAAK,CAAEoB,YAAa,CAAC,CAAG,KAAM,CAAAnE,QAAQ,CACzDiD,IAAI,CAAC,UAAU,CAAC,CAChBC,MAAM,2PAYZ,CAAC,CACK0E,EAAE,CAAC,UAAU,CAAEC,QAAQ,CAAC,CACxBE,KAAK,CAAC,cAAc,CAAE,CAAEC,SAAS,CAAE,KAAM,CAAC,CAAC,CAEhD,GAAI7D,YAAY,CAAE,KAAM,CAAAA,YAAY,CAEpC;AACA,KAAM,CAAAqF,UAAU,CAAG,CAACnD,QAAQ,EAAI,EAAE,EAAErE,GAAG,CAACgF,CAAC,EAAIA,CAAC,CAACrD,EAAE,CAAC,CAClD,KAAM,CAAEd,IAAI,CAAE4G,gBAAgB,CAAE1G,KAAK,CAAE2G,UAAW,CAAC,CAAG,KAAM,CAAA1J,QAAQ,CAC/DiD,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,YAAY,CAAC,CACpB0E,EAAE,CAAC,YAAY,CAAE4B,UAAU,CAAC,CAEjC;AACA,KAAM,CAAAG,QAAQ,CAAG,GAAI,CAAAzB,GAAG,CAAC,CAAC,CAC1B,CAACuB,gBAAgB,EAAI,EAAE,EAAEG,OAAO,CAACrE,CAAC,EAAI,CAClCoE,QAAQ,CAACE,GAAG,CAACtE,CAAC,CAACd,UAAU,CAAE,CAACkF,QAAQ,CAACf,GAAG,CAACrD,CAAC,CAACd,UAAU,CAAC,EAAI,CAAC,EAAI,CAAC,CAAC,CACrE,CAAC,CAAC,CAEF;AACA,KAAM,CAAA0D,SAAS,CAAG,EAAE,CACpB,KAAM,CAAAC,IAAI,CAAG,EAAE,CACf,KAAM,CAAAC,MAAM,CAAG,EAAE,CAEjB,IAAK,KAAM,CAAAhH,OAAO,GAAK,CAAAgF,QAAQ,EAAI,EAAE,CAAG,KAAAyD,iBAAA,CAAAC,qBAAA,CAAAC,iBAAA,CAAAC,qBAAA,CAAAC,iBAAA,CACpC,KAAM,CAAAxH,MAAM,CAAGtB,sBAAsB,CAACC,OAAO,CAAC,CAE9C,KAAM,CAAAwH,eAAe,CAAG,CACpBlF,EAAE,CAAEtC,OAAO,CAACsC,EAAE,CACdmF,UAAU,EAAAgB,iBAAA,CAAEzI,OAAO,CAAC6D,OAAO,UAAA4E,iBAAA,kBAAAC,qBAAA,CAAfD,iBAAA,CAAiBf,OAAO,UAAAgB,qBAAA,iBAAxBA,qBAAA,CAA0Bf,WAAW,CACjDC,WAAW,EAAAe,iBAAA,CAAE3I,OAAO,CAAC6D,OAAO,UAAA8E,iBAAA,kBAAAC,qBAAA,CAAfD,iBAAA,CAAiBjB,OAAO,UAAAkB,qBAAA,iBAAxBA,qBAAA,CAA0Bf,YAAY,CACnDC,SAAS,EAAAe,iBAAA,CAAE7I,OAAO,CAAC6D,OAAO,UAAAgF,iBAAA,iBAAfA,iBAAA,CAAiBd,UAAU,CACtCzI,IAAI,CAAE,GAAI,CAAAI,IAAI,CAACM,OAAO,CAACG,YAAY,CAAC,CAAC6H,kBAAkB,CAAC,CAAC,CACzD5H,SAAS,CAAEJ,OAAO,CAACK,UAAU,CAC7BC,OAAO,CAAEN,OAAO,CAACO,QAAQ,CACzBc,MAAM,CACNyH,eAAe,CAAER,QAAQ,CAACf,GAAG,CAACvH,OAAO,CAACsC,EAAE,CAAC,EAAI,CAAC,CAC9CuD,KAAK,CAAE7F,OAAO,CAAC6F,KACnB,CAAC,CAED,OAAQxE,MAAM,EACV,IAAK,CAAAzC,cAAc,CAACC,SAAS,CACzBiI,SAAS,CAACmB,IAAI,CAACT,eAAe,CAAC,CAC/B,MACJ,IAAK,CAAA5I,cAAc,CAACE,IAAI,CACpBiI,IAAI,CAACkB,IAAI,CAACT,eAAe,CAAC,CAC1B,MACJ,IAAK,CAAA5I,cAAc,CAACG,MAAM,CACtBiI,MAAM,CAACiB,IAAI,CAACT,eAAe,CAAC,CAC5B,MACR,CACJ,CAEA,MAAO,CAAEV,SAAS,CAAEC,IAAI,CAAEC,MAAM,CAAEtF,KAAK,CAAE,IAAK,CAAC,CACnD,CAAE,MAAOA,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,MAAO,CAAEoF,SAAS,CAAE,EAAE,CAAEC,IAAI,CAAE,EAAE,CAAEC,MAAM,CAAE,EAAE,CAAEtF,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CACxE,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAuF,qBAAqB,CAAG,KAAO,CAAAlG,SAAS,EAAK,CACtD,GAAI,CACA;AACA,KAAM,CAAAmG,MAAM,CAAG,KAAM,CAAAtF,sBAAsB,CAACb,SAAS,CAAC,CAEtD,GAAI,CAACmG,MAAM,CAACjG,OAAO,CAAE,CACjBU,OAAO,CAAC/B,KAAK,CAAC,sCAAsC,CAAEsH,MAAM,CAACtH,KAAK,CAAC,CACvE,CAAC,IAAM,CACH+B,OAAO,CAACwF,GAAG,YAAAvD,MAAA,CAAY7C,SAAS,cAAA6C,MAAA,CAAYsD,MAAM,CAACrF,WAAW,4BAA0B,CAAC,CAC7F,CAEA,MAAO,CAAAqF,MAAM,CACjB,CAAE,MAAOtH,KAAK,CAAE,CACZ+B,OAAO,CAAC/B,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,MAAO,CAAEqB,OAAO,CAAE,KAAK,CAAErB,KAAK,CAAEA,KAAK,CAAC8B,OAAQ,CAAC,CACnD,CACJ,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAA0F,gBAAgB,CAAIlJ,OAAO,EAAK,CACzC,KAAM,CAAAC,GAAG,CAAG,GAAI,CAAAP,IAAI,CAAC,CAAC,CAEtB;AACA,KAAM,CAAAQ,WAAW,CAAGF,OAAO,CAACG,YAAY,EAAIH,OAAO,CAACV,IAAI,CACxD,KAAM,CAAAc,SAAS,CAAGJ,OAAO,CAACK,UAAU,EAAIL,OAAO,CAACI,SAAS,CACzD,KAAM,CAAAE,OAAO,CAAGN,OAAO,CAACO,QAAQ,EAAIP,OAAO,CAACM,OAAO,CAEnD,KAAM,CAACE,SAAS,CAAEC,QAAQ,CAAC,CAAGL,SAAS,CAACM,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAC9D,KAAM,CAACC,OAAO,CAAEC,MAAM,CAAC,CAAGR,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC,CAExD,KAAM,CAAAG,gBAAgB,CAAG1B,aAAa,CAACa,WAAW,CAAEM,SAAS,CAAEC,QAAQ,CAAC,CACxE,KAAM,CAAAO,cAAc,CAAG3B,aAAa,CAACa,WAAW,CAAEW,OAAO,CAAEC,MAAM,CAAC,CAClE,KAAM,CAAAG,MAAM,CAAG,GAAI,CAAAvB,IAAI,CAACO,GAAG,CAACL,OAAO,CAAC,CAAC,CAAIK,GAAG,CAACiB,iBAAiB,CAAC,CAAC,CAAG,EAAE,CAAG,IAAK,CAAC,CAE9E,GAAID,MAAM,CAAGF,gBAAgB,CAAE,CAC3B,KAAM,CAAAoI,MAAM,CAAGpI,gBAAgB,CAAGE,MAAM,CACxC,KAAM,CAAAmI,OAAO,CAAGtD,IAAI,CAACuD,KAAK,CAACF,MAAM,CAAG,KAAK,CAAC,CAC1C,KAAM,CAAAG,KAAK,CAAGxD,IAAI,CAACuD,KAAK,CAACD,OAAO,CAAG,EAAE,CAAC,CACtC,KAAM,CAAAG,IAAI,CAAGH,OAAO,CAAG,EAAE,CAEzB,MAAO,CACHI,IAAI,CAAE,OAAO,CACbJ,OAAO,CACPK,SAAS,CAAEH,KAAK,CAAG,CAAC,IAAA5D,MAAA,CAAM4D,KAAK,OAAA5D,MAAA,CAAK6D,IAAI,qBAAA7D,MAAA,CAAqB6D,IAAI,iBACrE,CAAC,CACL,CAAC,IAAM,IAAItI,MAAM,CAAGD,cAAc,CAAE,CAChC,KAAM,CAAAmI,MAAM,CAAGnI,cAAc,CAAGC,MAAM,CACtC,KAAM,CAAAmI,OAAO,CAAGtD,IAAI,CAACuD,KAAK,CAACF,MAAM,CAAG,KAAK,CAAC,CAC1C,KAAM,CAAAG,KAAK,CAAGxD,IAAI,CAACuD,KAAK,CAACD,OAAO,CAAG,EAAE,CAAC,CACtC,KAAM,CAAAG,IAAI,CAAGH,OAAO,CAAG,EAAE,CAEzB,MAAO,CACHI,IAAI,CAAE,KAAK,CACXJ,OAAO,CACPK,SAAS,CAAEH,KAAK,CAAG,CAAC,IAAA5D,MAAA,CAAM4D,KAAK,OAAA5D,MAAA,CAAK6D,IAAI,mBAAA7D,MAAA,CAAmB6D,IAAI,eACnE,CAAC,CACL,CAEA,MAAO,CACHC,IAAI,CAAE,OAAO,CACbJ,OAAO,CAAE,CAAC,CACVK,SAAS,CAAE,eACf,CAAC,CACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}