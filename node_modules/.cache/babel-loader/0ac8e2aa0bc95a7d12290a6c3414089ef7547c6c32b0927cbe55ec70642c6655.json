{"ast":null,"code":"import _objectSpread from\"C:/Users/PFI/Desktop/ATTENDANCE/ATTENDANCE/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useEffect,useState}from'react';import{supabase}from'../supabase/supabase';import{jsx as _jsx}from\"react/jsx-runtime\";const AuthContext=/*#__PURE__*/createContext();export const useAuth=()=>useContext(AuthContext);export const AuthProvider=_ref=>{let{children}=_ref;const[currentUser,setCurrentUser]=useState(null);const[userRole,setUserRole]=useState(null);// 'student', 'delegate', 'admin'\nconst[loading,setLoading]=useState(true);const[error,setError]=useState(null);// Helper function to fetch and update user data\nconst updateUserFromDatabase=async userId=>{try{console.log('ðŸ“± AuthContext: Fetching role for userId:',userId);// Create a promise that rejects after 8 seconds\nconst timeoutPromise=new Promise((_,reject)=>setTimeout(()=>reject(new Error('Role fetch timeout')),8000));const queryPromise=(async()=>{const{data:userData,error:userError}=await supabase.from('users').select('id, role, name, matricule').eq('id',userId).single();if(userError){console.error('âŒ AuthContext: Query error:',userError);throw userError;}return userData;})();const userData=await Promise.race([queryPromise,timeoutPromise]);if(!userData){console.warn('âš ï¸ AuthContext: User not found in database for ID:',userId);return null;}console.log('âœ… AuthContext: Role retrieved:',userData===null||userData===void 0?void 0:userData.role);return userData;}catch(err){console.error('âŒ AuthContext: Role fetch error:',err.message);return null;}};useEffect(()=>{// Check for existing session on mount\nlet unsubscribed=false;const initAuth=async()=>{try{console.log('ðŸ“± AuthContext: Initializing auth on mount...');// Try to get session but don't wait - let the listener handle it\nsupabase.auth.getSession().then(_ref2=>{let{data:{session},error:sessionError}=_ref2;if(unsubscribed)return;if(sessionError){console.warn('âš ï¸ AuthContext: Session retrieval error:',sessionError.message);}if(session!==null&&session!==void 0&&session.user){console.log('ðŸ“± AuthContext: Existing session found for user:',session.user.email);updateUserFromDatabase(session.user.id).then(userData=>{if(!unsubscribed){setCurrentUser(_objectSpread(_objectSpread({},session.user),userData||{}));setUserRole((userData===null||userData===void 0?void 0:userData.role)||null);}});}}).catch(err=>{console.warn('âš ï¸ AuthContext: Session check failed:',err.message);});// Set loading to false immediately - don't wait for session check\nif(!unsubscribed){console.log('âœ… AuthContext: Loading complete (no wait)');setLoading(false);}}catch(err){console.error('âŒ AuthContext: Auth initialization error:',err.message);setError(err.message);if(!unsubscribed){setLoading(false);}}};initAuth();// Subscribe to auth changes\nconst{data:{subscription}}=supabase.auth.onAuthStateChange(async(event,session)=>{if(unsubscribed)return;console.log('ðŸ“± AuthContext: Auth state changed - Event type:',event,'| Session exists:',!!(session!==null&&session!==void 0&&session.user));try{if(session!==null&&session!==void 0&&session.user){console.log('ðŸ“± AuthContext: Processing auth state change for user:',session.user.email);const userData=await updateUserFromDatabase(session.user.id);if(!unsubscribed){setCurrentUser(_objectSpread(_objectSpread({},session.user),userData||{}));setUserRole((userData===null||userData===void 0?void 0:userData.role)||null);console.log('âœ… AuthContext: User state updated - Role:',userData===null||userData===void 0?void 0:userData.role);}}else{console.log('ðŸ“± AuthContext: Auth state change - no session, clearing user');if(!unsubscribed){setCurrentUser(null);setUserRole(null);}}}catch(err){console.error('âŒ AuthContext: Error processing auth state change:',err.message);setError(err.message);}});return()=>{unsubscribed=true;if(subscription){subscription.unsubscribe();}};},[]);const login=async(email,password)=>{try{var _data$user;console.log('ðŸ“± AuthContext.login: Logging in:',email);setError(null);const{data,error}=await supabase.auth.signInWithPassword({email,password});if(error){console.error('âŒ AuthContext.login: Auth error:',error.message);throw error;}console.log('âœ… AuthContext.login: Auth successful');// Set user immediately - don't wait for role\nsetCurrentUser(data.user);// Fetch role in background\nif((_data$user=data.user)!==null&&_data$user!==void 0&&_data$user.id){updateUserFromDatabase(data.user.id).then(userData=>{if(userData!==null&&userData!==void 0&&userData.role){setUserRole(userData.role);console.log('âœ… AuthContext.login: Role set:',userData.role);}}).catch(err=>{console.warn('âš ï¸ Background role fetch error:',err.message);});}return data.user;}catch(err){console.error('âŒ AuthContext.login: Error:',err.message);setError(err.message);throw err;}};const logout=async()=>{const{error}=await supabase.auth.signOut();if(error)throw error;};const value={currentUser,userRole,login,logout,loading,error};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:value,children:children});};","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","supabase","jsx","_jsx","AuthContext","useAuth","AuthProvider","_ref","children","currentUser","setCurrentUser","userRole","setUserRole","loading","setLoading","error","setError","updateUserFromDatabase","userId","console","log","timeoutPromise","Promise","_","reject","setTimeout","Error","queryPromise","data","userData","userError","from","select","eq","single","race","warn","role","err","message","unsubscribed","initAuth","auth","getSession","then","_ref2","session","sessionError","user","email","id","_objectSpread","catch","subscription","onAuthStateChange","event","unsubscribe","login","password","_data$user","signInWithPassword","logout","signOut","value","Provider"],"sources":["C:/Users/PFI/Desktop/ATTENDANCE/ATTENDANCE/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState } from 'react';\r\nimport { supabase } from '../supabase/supabase';\r\n\r\nconst AuthContext = createContext();\r\n\r\nexport const useAuth = () => useContext(AuthContext);\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [currentUser, setCurrentUser] = useState(null);\r\n  const [userRole, setUserRole] = useState(null); // 'student', 'delegate', 'admin'\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  // Helper function to fetch and update user data\r\n  const updateUserFromDatabase = async (userId) => {\r\n    try {\r\n      console.log('ðŸ“± AuthContext: Fetching role for userId:', userId);\r\n      \r\n      // Create a promise that rejects after 8 seconds\r\n      const timeoutPromise = new Promise((_, reject) =>\r\n        setTimeout(() => reject(new Error('Role fetch timeout')), 8000)\r\n      );\r\n      \r\n      const queryPromise = (async () => {\r\n        const { data: userData, error: userError } = await supabase\r\n          .from('users')\r\n          .select('id, role, name, matricule')\r\n          .eq('id', userId)\r\n          .single();\r\n        \r\n        if (userError) {\r\n          console.error('âŒ AuthContext: Query error:', userError);\r\n          throw userError;\r\n        }\r\n        \r\n        return userData;\r\n      })();\r\n      \r\n      const userData = await Promise.race([queryPromise, timeoutPromise]);\r\n      \r\n      if (!userData) {\r\n        console.warn('âš ï¸ AuthContext: User not found in database for ID:', userId);\r\n        return null;\r\n      }\r\n      \r\n      console.log('âœ… AuthContext: Role retrieved:', userData?.role);\r\n      return userData;\r\n    } catch (err) {\r\n      console.error('âŒ AuthContext: Role fetch error:', err.message);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Check for existing session on mount\r\n    let unsubscribed = false;\r\n\r\n    const initAuth = async () => {\r\n      try {\r\n        console.log('ðŸ“± AuthContext: Initializing auth on mount...');\r\n        \r\n        // Try to get session but don't wait - let the listener handle it\r\n        supabase.auth.getSession().then(({ data: { session }, error: sessionError }) => {\r\n          if (unsubscribed) return;\r\n          \r\n          if (sessionError) {\r\n            console.warn('âš ï¸ AuthContext: Session retrieval error:', sessionError.message);\r\n          }\r\n\r\n          if (session?.user) {\r\n            console.log('ðŸ“± AuthContext: Existing session found for user:', session.user.email);\r\n            updateUserFromDatabase(session.user.id).then(userData => {\r\n              if (!unsubscribed) {\r\n                setCurrentUser({ ...session.user, ...(userData || {}) });\r\n                setUserRole(userData?.role || null);\r\n              }\r\n            });\r\n          }\r\n        }).catch(err => {\r\n          console.warn('âš ï¸ AuthContext: Session check failed:', err.message);\r\n        });\r\n\r\n        // Set loading to false immediately - don't wait for session check\r\n        if (!unsubscribed) {\r\n          console.log('âœ… AuthContext: Loading complete (no wait)');\r\n          setLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error('âŒ AuthContext: Auth initialization error:', err.message);\r\n        setError(err.message);\r\n        if (!unsubscribed) {\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    initAuth();\r\n\r\n    // Subscribe to auth changes\r\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {\r\n      if (unsubscribed) return;\r\n      \r\n      console.log('ðŸ“± AuthContext: Auth state changed - Event type:', event, '| Session exists:', !!session?.user);\r\n      \r\n      try {\r\n        if (session?.user) {\r\n          console.log('ðŸ“± AuthContext: Processing auth state change for user:', session.user.email);\r\n          const userData = await updateUserFromDatabase(session.user.id);\r\n          \r\n          if (!unsubscribed) {\r\n            setCurrentUser({ ...session.user, ...(userData || {}) });\r\n            setUserRole(userData?.role || null);\r\n            console.log('âœ… AuthContext: User state updated - Role:', userData?.role);\r\n          }\r\n        } else {\r\n          console.log('ðŸ“± AuthContext: Auth state change - no session, clearing user');\r\n          if (!unsubscribed) {\r\n            setCurrentUser(null);\r\n            setUserRole(null);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('âŒ AuthContext: Error processing auth state change:', err.message);\r\n        setError(err.message);\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      unsubscribed = true;\r\n      if (subscription) {\r\n        subscription.unsubscribe();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const login = async (email, password) => {\r\n    try {\r\n      console.log('ðŸ“± AuthContext.login: Logging in:', email);\r\n      setError(null);\r\n      \r\n      const { data, error } = await supabase.auth.signInWithPassword({ email, password });\r\n      \r\n      if (error) {\r\n        console.error('âŒ AuthContext.login: Auth error:', error.message);\r\n        throw error;\r\n      }\r\n      \r\n      console.log('âœ… AuthContext.login: Auth successful');\r\n      \r\n      // Set user immediately - don't wait for role\r\n      setCurrentUser(data.user);\r\n      \r\n      // Fetch role in background\r\n      if (data.user?.id) {\r\n        updateUserFromDatabase(data.user.id).then(userData => {\r\n          if (userData?.role) {\r\n            setUserRole(userData.role);\r\n            console.log('âœ… AuthContext.login: Role set:', userData.role);\r\n          }\r\n        }).catch(err => {\r\n          console.warn('âš ï¸ Background role fetch error:', err.message);\r\n        });\r\n      }\r\n      \r\n      return data.user;\r\n    } catch (err) {\r\n      console.error('âŒ AuthContext.login: Error:', err.message);\r\n      setError(err.message);\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const logout = async () => {\r\n    const { error } = await supabase.auth.signOut();\r\n    if (error) throw error;\r\n  };\r\n\r\n  const value = {\r\n    currentUser,\r\n    userRole,\r\n    login,\r\n    logout,\r\n    loading,\r\n    error,\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}